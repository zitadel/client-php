<?php
/**
 * BetaUserServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zitadel SDK
 *
 * The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Zitadel\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zitadel\Client\ApiException;
use Zitadel\Client\Configuration;
use Zitadel\Client\ObjectSerializer;
use RuntimeException;
use Exception;

/**
 * BetaUserServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BetaUserServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addHumanUser' => [
            'application/json',
        ],
        'addIDPLink' => [
            'application/json',
        ],
        'addOTPEmail' => [
            'application/json',
        ],
        'addOTPSMS' => [
            'application/json',
        ],
        'createPasskeyRegistrationLink' => [
            'application/json',
        ],
        'deactivateUser' => [
            'application/json',
        ],
        'deleteUser' => [
            'application/json',
        ],
        'getUserByID' => [
            'application/json',
        ],
        'listAuthenticationMethodTypes' => [
            'application/json',
        ],
        'listUsers' => [
            'application/json',
        ],
        'lockUser' => [
            'application/json',
        ],
        'noOp' => [
            'application/json',
        ],
        'passwordReset' => [
            'application/json',
        ],
        'reactivateUser' => [
            'application/json',
        ],
        'registerPasskey' => [
            'application/json',
        ],
        'registerTOTP' => [
            'application/json',
        ],
        'registerU2F' => [
            'application/json',
        ],
        'removeOTPEmail' => [
            'application/json',
        ],
        'removeOTPSMS' => [
            'application/json',
        ],
        'removePhone' => [
            'application/json',
        ],
        'removeTOTP' => [
            'application/json',
        ],
        'resendEmailCode' => [
            'application/json',
        ],
        'resendPhoneCode' => [
            'application/json',
        ],
        'retrieveIdentityProviderIntent' => [
            'application/json',
        ],
        'setEmail' => [
            'application/json',
        ],
        'setPassword' => [
            'application/json',
        ],
        'setPhone' => [
            'application/json',
        ],
        'startIdentityProviderIntent' => [
            'application/json',
        ],
        'unlockUser' => [
            'application/json',
        ],
        'updateHumanUser' => [
            'application/json',
        ],
        'verifyEmail' => [
            'application/json',
        ],
        'verifyPasskeyRegistration' => [
            'application/json',
        ],
        'verifyPhone' => [
            'application/json',
        ],
        'verifyTOTPRegistration' => [
            'application/json',
        ],
        'verifyU2FRegistration' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        Configuration $config = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client([
            'http_errors' => false,
        ]);
        $this->config = $config;
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param string[] $accept
     * @param string $contentType
     * @param bool $isMultipart
     * @return string[]
     */
    private function selectHeaders(array $accept, string $contentType, bool $isMultipart): array
    {
        $headers = [];

        $accept = $this->selectAcceptHeader($accept);
        if ($accept !== null) {
            $headers['Accept'] = $accept;
        }

        if (!$isMultipart) {
            if ($contentType === '') {
                $contentType = 'application/json';
            }

            $headers['Content-Type'] = $contentType;
        }

        return $headers;
    }

    /**
     * Return the header 'Accept' based on an array of Accept provided.
     *
     * @param string[] $accept Array of header
     *
     * @return null|string Accept (e.g. application/json)
     */
    private function selectAcceptHeader(array $accept): ?string
    {
        # filter out empty entries
        $accept = array_filter($accept);

        if (count($accept) === 0) {
            return null;
        }

        # If there's only one Accept header, just use it
        if (count($accept) === 1) {
            return reset($accept);
        }

        # If none of the available Accept headers is of type "json", then just use all them
        $headersWithJson = $this->selectJsonMimeList($accept);
        if (count($headersWithJson) === 0) {
            return implode(',', $accept);
        }

        # If we got here, then we need add quality values (weight), as described in IETF RFC 9110, Items 12.4.2/12.5.1,
        # to give the highest priority to json-like headers - recalculating the existing ones, if needed
        return $this->getAcceptHeaderWithAdjustedWeight($accept, $headersWithJson);
    }

    /**
     * Select all items from a list containing a JSON mime type
     *
     * @param array $mimeList
     * @return array
     */
    private function selectJsonMimeList(array $mimeList): array
    {
        $jsonMimeList = [];
        foreach ($mimeList as $mime) {
            if ($this->isJsonMime($mime)) {
                $jsonMimeList[] = $mime;
            }
        }
        return $jsonMimeList;
    }

    /**
     * Detects whether a string contains a valid JSON mime type
     *
     * @param string $searchString
     * @return bool
     */
    private function isJsonMime(string $searchString): bool
    {
        /** @noinspection PhpCoveredCharacterInClassInspection */
        return preg_match('~^application/(json|[\w!#$&.+-^_]+\+json)\s*(;|$)~', $searchString) === 1;
    }

    /**
     * Create an Accept header string from the given "Accept" headers array, recalculating all weights
     *
     * @param string[] $accept Array of Accept Headers
     * @param string[] $headersWithJson Array of Accept Headers of type "json"
     *
     * @return string "Accept" Header (e.g. "application/json, text/html; q=0.9")
     */
    private function getAcceptHeaderWithAdjustedWeight(array $accept, array $headersWithJson): string
    {
        $processedHeaders = [
          'withApplicationJson' => [],
          'withJson' => [],
          'withoutJson' => [],
        ];

        foreach ($accept as $header) {

            $headerData = $this->getHeaderAndWeight($header);

            if (stripos($headerData['header'], 'application/json') === 0) {
                $processedHeaders['withApplicationJson'][] = $headerData;
            } elseif (in_array($header, $headersWithJson, true)) {
                $processedHeaders['withJson'][] = $headerData;
            } else {
                $processedHeaders['withoutJson'][] = $headerData;
            }
        }

        $acceptHeaders = [];
        $currentWeight = 1000;

        $hasMoreThan28Headers = count($accept) > 28;

        foreach ($processedHeaders as $headers) {
            if (count($headers) > 0) {
                $acceptHeaders[] = $this->adjustWeight($headers, $currentWeight, $hasMoreThan28Headers);
            }
        }

        $acceptHeaders = array_merge(...$acceptHeaders);

        return implode(',', $acceptHeaders);
    }

    /**
     * Given an Accept header, returns an associative array splitting the header and its weight
     *
     * @param string $header "Accept" Header
     *
     * @return array with the header and its weight
     */
    private function getHeaderAndWeight(string $header): array
    {
        # matches headers with weight, splitting the header and the weight in $outputArray
        if (preg_match('/(.*);\s*q=(1(?:\.0+)?|0\.\d+)$/', $header, $outputArray) === 1) {
            $headerData = [
              'header' => $outputArray[1],
              'weight' => (int)($outputArray[2] * 1000),
            ];
        } else {
            $headerData = [
              'header' => trim($header),
              'weight' => 1000,
            ];
        }

        return $headerData;
    }

    /**
     * @param array[] $headers
     * @param float $currentWeight
     * @param bool $hasMoreThan28Headers
     * @return string[] array of adjusted "Accept" headers
     */
    private function adjustWeight(array $headers, float &$currentWeight, bool $hasMoreThan28Headers): array
    {
        usort($headers, fn (array $a, array $b) => $b['weight'] - $a['weight']);

        $acceptHeaders = [];
        foreach ($headers as $index => $header) {
            if ($index > 0 && $headers[$index - 1]['weight'] > $header['weight']) {
                $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);
            }

            $weight = $currentWeight;

            $acceptHeaders[] = $this->buildAcceptHeader($header['header'], $weight);
        }

        $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);

        return $acceptHeaders;
    }

    /**
     * Calculate the next weight, based on the current one.
     *
     * If there are less than 28 "Accept" headers, the weights will be decreased by 1 on its highest significant digit, using the
     * following formula:
     *
     *    next weight = current weight - 10 ^ (floor(log(current weight - 1)))
     *
     *    ( current weight minus ( 10 raised to the power of ( floor of (log to the base 10 of ( current weight minus 1 ) ) ) ) )
     *
     * Starting from 1000, this generates the following series:
     *
     * 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
     *
     * The resulting quality codes are closer to the average "normal" usage of them (like "q=0.9", "q=0.8" and so on), but it only works
     * if there is a maximum of 28 "Accept" headers. If we have more than that (which is extremely unlikely), then we fall back to a 1-by-1
     * decrement rule, which will result in quality codes like "q=0.999", "q=0.998" etc.
     *
     * @param int $currentWeight varying from 1 to 1000 (will be divided by 1000 to build the quality value)
     * @param bool $hasMoreThan28Headers
     * @return int
     */
    private function getNextWeight(int $currentWeight, bool $hasMoreThan28Headers): int
    {
        if ($currentWeight <= 1) {
            return 1;
        }

        if ($hasMoreThan28Headers) {
            return $currentWeight - 1;
        }

        return $currentWeight - 10 ** floor(log10($currentWeight - 1));
    }

    /**
     * @param string $header
     * @param int $weight
     * @return string
     */
    private function buildAcceptHeader(string $header, int $weight): string
    {
        if ($weight === 1000) {
            return $header;
        }

        return trim($header, '; ') . ';q=' . rtrim(sprintf('%0.3f', $weight / 1000), '0');
    }


        /**
     * @throws ApiException
     */
    private function executeRequest(
        Request $request,
        array $responseTypes,
        string $defaultResponseType
    ): mixed {
        try {
            $options = $this->createHttpClientOption();
            $response = $this->client->send($request, $options);
        } catch (GuzzleException $e) {
            throw new RuntimeException(
                "API Request failed: [{$e->getCode()}] {$e->getMessage()}",
                (int) $e->getCode(),
                $e
            );
        }

        $statusCode = $response->getStatusCode();
        $responseBody = $response->getBody();
        $responseHeaders = $response->getHeaders();

        if ($statusCode >= 200 && $statusCode < 300) {
            $returnType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($returnType === '\SplFileObject') {
                return $responseBody;
            } else {
                $content = (string) $responseBody;

                if (empty(trim($content)) && $returnType !== 'string') {
                    $content = null;
                }

                try {
                    return ObjectSerializer::deserialize($content, $returnType, $this->config, []);
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process successful response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            }
        } else {
            $errorType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($errorType === '\SplFileObject') {
                throw new ApiException(
                    sprintf('[%d] API Error (%s) - Expected file object', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            } elseif ($errorType !== 'string' && !empty(trim((string) $responseBody))) {
                try {
                    $decodedContent = json_decode((string)$responseBody, false, 512, JSON_THROW_ON_ERROR);
                    throw new ApiException(
                        sprintf('[%d] API Error (%s)', $statusCode, (string)$request->getUri()),
                        $statusCode,
                        $responseHeaders,
                        $decodedContent,
                    );
                } catch (ApiException $e) {
                    throw $e;
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process error response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            } else {
                throw new ApiException(
                    sprintf('[%d] API Error (%s)', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            }
        }
    }

    /**
     * Operation addHumanUser
     *
     * AddHumanUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddHumanUserRequest $betaUserServiceAddHumanUserRequest betaUserServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceAddHumanUserResponse
     * @throws ApiException
     */
    public function addHumanUser(    $betaUserServiceAddHumanUserRequest,string $contentType = self::contentTypes['addHumanUser'][0])
    {
        $request = $this->addHumanUserRequest($betaUserServiceAddHumanUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceAddHumanUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceAddHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addHumanUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddHumanUserRequest $betaUserServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addHumanUserRequest($betaUserServiceAddHumanUserRequest, string $contentType = self::contentTypes['addHumanUser'][0])
    {

        if ($betaUserServiceAddHumanUserRequest === null || (is_array($betaUserServiceAddHumanUserRequest) && count($betaUserServiceAddHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceAddHumanUserRequest when calling addHumanUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/AddHumanUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceAddHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceAddHumanUserRequest));
            } else {
                $httpBody = $betaUserServiceAddHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addIDPLink
     *
     * AddIDPLink
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddIDPLinkRequest $betaUserServiceAddIDPLinkRequest betaUserServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIDPLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceAddIDPLinkResponse
     * @throws ApiException
     */
    public function addIDPLink(    $betaUserServiceAddIDPLinkRequest,string $contentType = self::contentTypes['addIDPLink'][0])
    {
        $request = $this->addIDPLinkRequest($betaUserServiceAddIDPLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceAddIDPLinkResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceAddIDPLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addIDPLink'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddIDPLinkRequest $betaUserServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIDPLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addIDPLinkRequest($betaUserServiceAddIDPLinkRequest, string $contentType = self::contentTypes['addIDPLink'][0])
    {

        if ($betaUserServiceAddIDPLinkRequest === null || (is_array($betaUserServiceAddIDPLinkRequest) && count($betaUserServiceAddIDPLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceAddIDPLinkRequest when calling addIDPLink'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/AddIDPLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceAddIDPLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceAddIDPLinkRequest));
            } else {
                $httpBody = $betaUserServiceAddIDPLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addOTPEmail
     *
     * AddOTPEmail
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddOTPEmailRequest $betaUserServiceAddOTPEmailRequest betaUserServiceAddOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceAddOTPEmailResponse
     * @throws ApiException
     */
    public function addOTPEmail(    $betaUserServiceAddOTPEmailRequest,string $contentType = self::contentTypes['addOTPEmail'][0])
    {
        $request = $this->addOTPEmailRequest($betaUserServiceAddOTPEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceAddOTPEmailResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceAddOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addOTPEmail'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddOTPEmailRequest $betaUserServiceAddOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addOTPEmailRequest($betaUserServiceAddOTPEmailRequest, string $contentType = self::contentTypes['addOTPEmail'][0])
    {

        if ($betaUserServiceAddOTPEmailRequest === null || (is_array($betaUserServiceAddOTPEmailRequest) && count($betaUserServiceAddOTPEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceAddOTPEmailRequest when calling addOTPEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/AddOTPEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceAddOTPEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceAddOTPEmailRequest));
            } else {
                $httpBody = $betaUserServiceAddOTPEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addOTPSMS
     *
     * AddOTPSMS
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddOTPSMSRequest $betaUserServiceAddOTPSMSRequest betaUserServiceAddOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceAddOTPSMSResponse
     * @throws ApiException
     */
    public function addOTPSMS(    $betaUserServiceAddOTPSMSRequest,string $contentType = self::contentTypes['addOTPSMS'][0])
    {
        $request = $this->addOTPSMSRequest($betaUserServiceAddOTPSMSRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceAddOTPSMSResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceAddOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addOTPSMS'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceAddOTPSMSRequest $betaUserServiceAddOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addOTPSMSRequest($betaUserServiceAddOTPSMSRequest, string $contentType = self::contentTypes['addOTPSMS'][0])
    {

        if ($betaUserServiceAddOTPSMSRequest === null || (is_array($betaUserServiceAddOTPSMSRequest) && count($betaUserServiceAddOTPSMSRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceAddOTPSMSRequest when calling addOTPSMS'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/AddOTPSMS';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceAddOTPSMSRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceAddOTPSMSRequest));
            } else {
                $httpBody = $betaUserServiceAddOTPSMSRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPasskeyRegistrationLink
     *
     * CreatePasskeyRegistrationLink
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceCreatePasskeyRegistrationLinkRequest $betaUserServiceCreatePasskeyRegistrationLinkRequest betaUserServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceCreatePasskeyRegistrationLinkResponse
     * @throws ApiException
     */
    public function createPasskeyRegistrationLink(    $betaUserServiceCreatePasskeyRegistrationLinkRequest,string $contentType = self::contentTypes['createPasskeyRegistrationLink'][0])
    {
        $request = $this->createPasskeyRegistrationLinkRequest($betaUserServiceCreatePasskeyRegistrationLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceCreatePasskeyRegistrationLinkResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceCreatePasskeyRegistrationLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'createPasskeyRegistrationLink'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceCreatePasskeyRegistrationLinkRequest $betaUserServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function createPasskeyRegistrationLinkRequest($betaUserServiceCreatePasskeyRegistrationLinkRequest, string $contentType = self::contentTypes['createPasskeyRegistrationLink'][0])
    {

        if ($betaUserServiceCreatePasskeyRegistrationLinkRequest === null || (is_array($betaUserServiceCreatePasskeyRegistrationLinkRequest) && count($betaUserServiceCreatePasskeyRegistrationLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceCreatePasskeyRegistrationLinkRequest when calling createPasskeyRegistrationLink'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/CreatePasskeyRegistrationLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceCreatePasskeyRegistrationLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceCreatePasskeyRegistrationLinkRequest));
            } else {
                $httpBody = $betaUserServiceCreatePasskeyRegistrationLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deactivateUser
     *
     * DeactivateUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceDeactivateUserRequest $betaUserServiceDeactivateUserRequest betaUserServiceDeactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceDeactivateUserResponse
     * @throws ApiException
     */
    public function deactivateUser(    $betaUserServiceDeactivateUserRequest,string $contentType = self::contentTypes['deactivateUser'][0])
    {
        $request = $this->deactivateUserRequest($betaUserServiceDeactivateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceDeactivateUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceDeactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'deactivateUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceDeactivateUserRequest $betaUserServiceDeactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function deactivateUserRequest($betaUserServiceDeactivateUserRequest, string $contentType = self::contentTypes['deactivateUser'][0])
    {

        if ($betaUserServiceDeactivateUserRequest === null || (is_array($betaUserServiceDeactivateUserRequest) && count($betaUserServiceDeactivateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceDeactivateUserRequest when calling deactivateUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/DeactivateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceDeactivateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceDeactivateUserRequest));
            } else {
                $httpBody = $betaUserServiceDeactivateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUser
     *
     * DeleteUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceDeleteUserRequest $betaUserServiceDeleteUserRequest betaUserServiceDeleteUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceDeleteUserResponse
     * @throws ApiException
     */
    public function deleteUser(    $betaUserServiceDeleteUserRequest,string $contentType = self::contentTypes['deleteUser'][0])
    {
        $request = $this->deleteUserRequest($betaUserServiceDeleteUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceDeleteUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceDeleteUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'deleteUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceDeleteUserRequest $betaUserServiceDeleteUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function deleteUserRequest($betaUserServiceDeleteUserRequest, string $contentType = self::contentTypes['deleteUser'][0])
    {

        if ($betaUserServiceDeleteUserRequest === null || (is_array($betaUserServiceDeleteUserRequest) && count($betaUserServiceDeleteUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceDeleteUserRequest when calling deleteUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/DeleteUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceDeleteUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceDeleteUserRequest));
            } else {
                $httpBody = $betaUserServiceDeleteUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserByID
     *
     * GetUserByID
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceGetUserByIDRequest $betaUserServiceGetUserByIDRequest betaUserServiceGetUserByIDRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserByID'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceGetUserByIDResponse
     * @throws ApiException
     */
    public function getUserByID(    $betaUserServiceGetUserByIDRequest,string $contentType = self::contentTypes['getUserByID'][0])
    {
        $request = $this->getUserByIDRequest($betaUserServiceGetUserByIDRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceGetUserByIDResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceGetUserByIDResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'getUserByID'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceGetUserByIDRequest $betaUserServiceGetUserByIDRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function getUserByIDRequest($betaUserServiceGetUserByIDRequest, string $contentType = self::contentTypes['getUserByID'][0])
    {

        if ($betaUserServiceGetUserByIDRequest === null || (is_array($betaUserServiceGetUserByIDRequest) && count($betaUserServiceGetUserByIDRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceGetUserByIDRequest when calling getUserByID'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/GetUserByID';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceGetUserByIDRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceGetUserByIDRequest));
            } else {
                $httpBody = $betaUserServiceGetUserByIDRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAuthenticationMethodTypes
     *
     * ListAuthenticationMethodTypes
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceListAuthenticationMethodTypesRequest $betaUserServiceListAuthenticationMethodTypesRequest betaUserServiceListAuthenticationMethodTypesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceListAuthenticationMethodTypesResponse
     * @throws ApiException
     */
    public function listAuthenticationMethodTypes(    $betaUserServiceListAuthenticationMethodTypesRequest,string $contentType = self::contentTypes['listAuthenticationMethodTypes'][0])
    {
        $request = $this->listAuthenticationMethodTypesRequest($betaUserServiceListAuthenticationMethodTypesRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceListAuthenticationMethodTypesResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceListAuthenticationMethodTypesResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listAuthenticationMethodTypes'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceListAuthenticationMethodTypesRequest $betaUserServiceListAuthenticationMethodTypesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listAuthenticationMethodTypesRequest($betaUserServiceListAuthenticationMethodTypesRequest, string $contentType = self::contentTypes['listAuthenticationMethodTypes'][0])
    {

        if ($betaUserServiceListAuthenticationMethodTypesRequest === null || (is_array($betaUserServiceListAuthenticationMethodTypesRequest) && count($betaUserServiceListAuthenticationMethodTypesRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceListAuthenticationMethodTypesRequest when calling listAuthenticationMethodTypes'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/ListAuthenticationMethodTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceListAuthenticationMethodTypesRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceListAuthenticationMethodTypesRequest));
            } else {
                $httpBody = $betaUserServiceListAuthenticationMethodTypesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * ListUsers
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceListUsersRequest $betaUserServiceListUsersRequest betaUserServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceListUsersResponse
     * @throws ApiException
     */
    public function listUsers(    $betaUserServiceListUsersRequest,string $contentType = self::contentTypes['listUsers'][0])
    {
        $request = $this->listUsersRequest($betaUserServiceListUsersRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceListUsersResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceListUsersResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listUsers'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceListUsersRequest $betaUserServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listUsersRequest($betaUserServiceListUsersRequest, string $contentType = self::contentTypes['listUsers'][0])
    {

        if ($betaUserServiceListUsersRequest === null || (is_array($betaUserServiceListUsersRequest) && count($betaUserServiceListUsersRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceListUsersRequest when calling listUsers'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/ListUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceListUsersRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceListUsersRequest));
            } else {
                $httpBody = $betaUserServiceListUsersRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockUser
     *
     * LockUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceLockUserRequest $betaUserServiceLockUserRequest betaUserServiceLockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceLockUserResponse
     * @throws ApiException
     */
    public function lockUser(    $betaUserServiceLockUserRequest,string $contentType = self::contentTypes['lockUser'][0])
    {
        $request = $this->lockUserRequest($betaUserServiceLockUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceLockUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceLockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'lockUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceLockUserRequest $betaUserServiceLockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function lockUserRequest($betaUserServiceLockUserRequest, string $contentType = self::contentTypes['lockUser'][0])
    {

        if ($betaUserServiceLockUserRequest === null || (is_array($betaUserServiceLockUserRequest) && count($betaUserServiceLockUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceLockUserRequest when calling lockUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/LockUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceLockUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceLockUserRequest));
            } else {
                $httpBody = $betaUserServiceLockUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation noOp
     *
     * Dummy endpoint to retain union-member schemas
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['noOp'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\NoOp200Response12
     * @throws ApiException
     */
    public function noOp(string $contentType = self::contentTypes['noOp'][0])
    {
        $request = $this->noOpRequest($contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\NoOp200Response12',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\NoOp200Response12';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'noOp'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['noOp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function noOpRequest(string $contentType = self::contentTypes['noOp'][0])
    {


        $resourcePath = '/ac7df331';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation passwordReset
     *
     * PasswordReset
     *
     * @param  \Zitadel\Client\Model\BetaUserServicePasswordResetRequest $betaUserServicePasswordResetRequest betaUserServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['passwordReset'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServicePasswordResetResponse
     * @throws ApiException
     */
    public function passwordReset(    $betaUserServicePasswordResetRequest,string $contentType = self::contentTypes['passwordReset'][0])
    {
        $request = $this->passwordResetRequest($betaUserServicePasswordResetRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServicePasswordResetResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServicePasswordResetResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'passwordReset'
     *
     * @param  \Zitadel\Client\Model\BetaUserServicePasswordResetRequest $betaUserServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['passwordReset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function passwordResetRequest($betaUserServicePasswordResetRequest, string $contentType = self::contentTypes['passwordReset'][0])
    {

        if ($betaUserServicePasswordResetRequest === null || (is_array($betaUserServicePasswordResetRequest) && count($betaUserServicePasswordResetRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServicePasswordResetRequest when calling passwordReset'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/PasswordReset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServicePasswordResetRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServicePasswordResetRequest));
            } else {
                $httpBody = $betaUserServicePasswordResetRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reactivateUser
     *
     * ReactivateUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceReactivateUserRequest $betaUserServiceReactivateUserRequest betaUserServiceReactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceReactivateUserResponse
     * @throws ApiException
     */
    public function reactivateUser(    $betaUserServiceReactivateUserRequest,string $contentType = self::contentTypes['reactivateUser'][0])
    {
        $request = $this->reactivateUserRequest($betaUserServiceReactivateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceReactivateUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceReactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'reactivateUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceReactivateUserRequest $betaUserServiceReactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function reactivateUserRequest($betaUserServiceReactivateUserRequest, string $contentType = self::contentTypes['reactivateUser'][0])
    {

        if ($betaUserServiceReactivateUserRequest === null || (is_array($betaUserServiceReactivateUserRequest) && count($betaUserServiceReactivateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceReactivateUserRequest when calling reactivateUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/ReactivateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceReactivateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceReactivateUserRequest));
            } else {
                $httpBody = $betaUserServiceReactivateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerPasskey
     *
     * RegisterPasskey
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterPasskeyRequest $betaUserServiceRegisterPasskeyRequest betaUserServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerPasskey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRegisterPasskeyResponse
     * @throws ApiException
     */
    public function registerPasskey(    $betaUserServiceRegisterPasskeyRequest,string $contentType = self::contentTypes['registerPasskey'][0])
    {
        $request = $this->registerPasskeyRequest($betaUserServiceRegisterPasskeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRegisterPasskeyResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRegisterPasskeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerPasskey'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterPasskeyRequest $betaUserServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerPasskey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerPasskeyRequest($betaUserServiceRegisterPasskeyRequest, string $contentType = self::contentTypes['registerPasskey'][0])
    {

        if ($betaUserServiceRegisterPasskeyRequest === null || (is_array($betaUserServiceRegisterPasskeyRequest) && count($betaUserServiceRegisterPasskeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRegisterPasskeyRequest when calling registerPasskey'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RegisterPasskey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRegisterPasskeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRegisterPasskeyRequest));
            } else {
                $httpBody = $betaUserServiceRegisterPasskeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerTOTP
     *
     * RegisterTOTP
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterTOTPRequest $betaUserServiceRegisterTOTPRequest betaUserServiceRegisterTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRegisterTOTPResponse
     * @throws ApiException
     */
    public function registerTOTP(    $betaUserServiceRegisterTOTPRequest,string $contentType = self::contentTypes['registerTOTP'][0])
    {
        $request = $this->registerTOTPRequest($betaUserServiceRegisterTOTPRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRegisterTOTPResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRegisterTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerTOTP'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterTOTPRequest $betaUserServiceRegisterTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerTOTPRequest($betaUserServiceRegisterTOTPRequest, string $contentType = self::contentTypes['registerTOTP'][0])
    {

        if ($betaUserServiceRegisterTOTPRequest === null || (is_array($betaUserServiceRegisterTOTPRequest) && count($betaUserServiceRegisterTOTPRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRegisterTOTPRequest when calling registerTOTP'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RegisterTOTP';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRegisterTOTPRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRegisterTOTPRequest));
            } else {
                $httpBody = $betaUserServiceRegisterTOTPRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerU2F
     *
     * RegisterU2F
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterU2FRequest $betaUserServiceRegisterU2FRequest betaUserServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerU2F'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRegisterU2FResponse
     * @throws ApiException
     */
    public function registerU2F(    $betaUserServiceRegisterU2FRequest,string $contentType = self::contentTypes['registerU2F'][0])
    {
        $request = $this->registerU2FRequest($betaUserServiceRegisterU2FRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRegisterU2FResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRegisterU2FResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerU2F'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRegisterU2FRequest $betaUserServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerU2F'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerU2FRequest($betaUserServiceRegisterU2FRequest, string $contentType = self::contentTypes['registerU2F'][0])
    {

        if ($betaUserServiceRegisterU2FRequest === null || (is_array($betaUserServiceRegisterU2FRequest) && count($betaUserServiceRegisterU2FRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRegisterU2FRequest when calling registerU2F'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RegisterU2F';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRegisterU2FRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRegisterU2FRequest));
            } else {
                $httpBody = $betaUserServiceRegisterU2FRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeOTPEmail
     *
     * RemoveOTPEmail
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveOTPEmailRequest $betaUserServiceRemoveOTPEmailRequest betaUserServiceRemoveOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRemoveOTPEmailResponse
     * @throws ApiException
     */
    public function removeOTPEmail(    $betaUserServiceRemoveOTPEmailRequest,string $contentType = self::contentTypes['removeOTPEmail'][0])
    {
        $request = $this->removeOTPEmailRequest($betaUserServiceRemoveOTPEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRemoveOTPEmailResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRemoveOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeOTPEmail'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveOTPEmailRequest $betaUserServiceRemoveOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeOTPEmailRequest($betaUserServiceRemoveOTPEmailRequest, string $contentType = self::contentTypes['removeOTPEmail'][0])
    {

        if ($betaUserServiceRemoveOTPEmailRequest === null || (is_array($betaUserServiceRemoveOTPEmailRequest) && count($betaUserServiceRemoveOTPEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRemoveOTPEmailRequest when calling removeOTPEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RemoveOTPEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRemoveOTPEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRemoveOTPEmailRequest));
            } else {
                $httpBody = $betaUserServiceRemoveOTPEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeOTPSMS
     *
     * RemoveOTPSMS
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveOTPSMSRequest $betaUserServiceRemoveOTPSMSRequest betaUserServiceRemoveOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRemoveOTPSMSResponse
     * @throws ApiException
     */
    public function removeOTPSMS(    $betaUserServiceRemoveOTPSMSRequest,string $contentType = self::contentTypes['removeOTPSMS'][0])
    {
        $request = $this->removeOTPSMSRequest($betaUserServiceRemoveOTPSMSRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRemoveOTPSMSResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRemoveOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeOTPSMS'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveOTPSMSRequest $betaUserServiceRemoveOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeOTPSMSRequest($betaUserServiceRemoveOTPSMSRequest, string $contentType = self::contentTypes['removeOTPSMS'][0])
    {

        if ($betaUserServiceRemoveOTPSMSRequest === null || (is_array($betaUserServiceRemoveOTPSMSRequest) && count($betaUserServiceRemoveOTPSMSRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRemoveOTPSMSRequest when calling removeOTPSMS'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RemoveOTPSMS';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRemoveOTPSMSRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRemoveOTPSMSRequest));
            } else {
                $httpBody = $betaUserServiceRemoveOTPSMSRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePhone
     *
     * RemovePhone
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemovePhoneRequest $betaUserServiceRemovePhoneRequest betaUserServiceRemovePhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRemovePhoneResponse
     * @throws ApiException
     */
    public function removePhone(    $betaUserServiceRemovePhoneRequest,string $contentType = self::contentTypes['removePhone'][0])
    {
        $request = $this->removePhoneRequest($betaUserServiceRemovePhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRemovePhoneResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRemovePhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removePhone'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemovePhoneRequest $betaUserServiceRemovePhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removePhoneRequest($betaUserServiceRemovePhoneRequest, string $contentType = self::contentTypes['removePhone'][0])
    {

        if ($betaUserServiceRemovePhoneRequest === null || (is_array($betaUserServiceRemovePhoneRequest) && count($betaUserServiceRemovePhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRemovePhoneRequest when calling removePhone'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RemovePhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRemovePhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRemovePhoneRequest));
            } else {
                $httpBody = $betaUserServiceRemovePhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeTOTP
     *
     * RemoveTOTP
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveTOTPRequest $betaUserServiceRemoveTOTPRequest betaUserServiceRemoveTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRemoveTOTPResponse
     * @throws ApiException
     */
    public function removeTOTP(    $betaUserServiceRemoveTOTPRequest,string $contentType = self::contentTypes['removeTOTP'][0])
    {
        $request = $this->removeTOTPRequest($betaUserServiceRemoveTOTPRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRemoveTOTPResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRemoveTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeTOTP'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRemoveTOTPRequest $betaUserServiceRemoveTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeTOTPRequest($betaUserServiceRemoveTOTPRequest, string $contentType = self::contentTypes['removeTOTP'][0])
    {

        if ($betaUserServiceRemoveTOTPRequest === null || (is_array($betaUserServiceRemoveTOTPRequest) && count($betaUserServiceRemoveTOTPRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRemoveTOTPRequest when calling removeTOTP'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RemoveTOTP';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRemoveTOTPRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRemoveTOTPRequest));
            } else {
                $httpBody = $betaUserServiceRemoveTOTPRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendEmailCode
     *
     * ResendEmailCode
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceResendEmailCodeRequest $betaUserServiceResendEmailCodeRequest betaUserServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceResendEmailCodeResponse
     * @throws ApiException
     */
    public function resendEmailCode(    $betaUserServiceResendEmailCodeRequest,string $contentType = self::contentTypes['resendEmailCode'][0])
    {
        $request = $this->resendEmailCodeRequest($betaUserServiceResendEmailCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceResendEmailCodeResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceResendEmailCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'resendEmailCode'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceResendEmailCodeRequest $betaUserServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function resendEmailCodeRequest($betaUserServiceResendEmailCodeRequest, string $contentType = self::contentTypes['resendEmailCode'][0])
    {

        if ($betaUserServiceResendEmailCodeRequest === null || (is_array($betaUserServiceResendEmailCodeRequest) && count($betaUserServiceResendEmailCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceResendEmailCodeRequest when calling resendEmailCode'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/ResendEmailCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceResendEmailCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceResendEmailCodeRequest));
            } else {
                $httpBody = $betaUserServiceResendEmailCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendPhoneCode
     *
     * ResendPhoneCode
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceResendPhoneCodeRequest $betaUserServiceResendPhoneCodeRequest betaUserServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendPhoneCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceResendPhoneCodeResponse
     * @throws ApiException
     */
    public function resendPhoneCode(    $betaUserServiceResendPhoneCodeRequest,string $contentType = self::contentTypes['resendPhoneCode'][0])
    {
        $request = $this->resendPhoneCodeRequest($betaUserServiceResendPhoneCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceResendPhoneCodeResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceResendPhoneCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'resendPhoneCode'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceResendPhoneCodeRequest $betaUserServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendPhoneCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function resendPhoneCodeRequest($betaUserServiceResendPhoneCodeRequest, string $contentType = self::contentTypes['resendPhoneCode'][0])
    {

        if ($betaUserServiceResendPhoneCodeRequest === null || (is_array($betaUserServiceResendPhoneCodeRequest) && count($betaUserServiceResendPhoneCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceResendPhoneCodeRequest when calling resendPhoneCode'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/ResendPhoneCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceResendPhoneCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceResendPhoneCodeRequest));
            } else {
                $httpBody = $betaUserServiceResendPhoneCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveIdentityProviderIntent
     *
     * RetrieveIdentityProviderIntent
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRetrieveIdentityProviderIntentRequest $betaUserServiceRetrieveIdentityProviderIntentRequest betaUserServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceRetrieveIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function retrieveIdentityProviderIntent(    $betaUserServiceRetrieveIdentityProviderIntentRequest,string $contentType = self::contentTypes['retrieveIdentityProviderIntent'][0])
    {
        $request = $this->retrieveIdentityProviderIntentRequest($betaUserServiceRetrieveIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceRetrieveIdentityProviderIntentResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceRetrieveIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'retrieveIdentityProviderIntent'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceRetrieveIdentityProviderIntentRequest $betaUserServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function retrieveIdentityProviderIntentRequest($betaUserServiceRetrieveIdentityProviderIntentRequest, string $contentType = self::contentTypes['retrieveIdentityProviderIntent'][0])
    {

        if ($betaUserServiceRetrieveIdentityProviderIntentRequest === null || (is_array($betaUserServiceRetrieveIdentityProviderIntentRequest) && count($betaUserServiceRetrieveIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceRetrieveIdentityProviderIntentRequest when calling retrieveIdentityProviderIntent'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/RetrieveIdentityProviderIntent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceRetrieveIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceRetrieveIdentityProviderIntentRequest));
            } else {
                $httpBody = $betaUserServiceRetrieveIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setEmail
     *
     * SetEmail
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetEmailRequest $betaUserServiceSetEmailRequest betaUserServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceSetEmailResponse
     * @throws ApiException
     */
    public function setEmail(    $betaUserServiceSetEmailRequest,string $contentType = self::contentTypes['setEmail'][0])
    {
        $request = $this->setEmailRequest($betaUserServiceSetEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceSetEmailResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceSetEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setEmail'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetEmailRequest $betaUserServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setEmailRequest($betaUserServiceSetEmailRequest, string $contentType = self::contentTypes['setEmail'][0])
    {

        if ($betaUserServiceSetEmailRequest === null || (is_array($betaUserServiceSetEmailRequest) && count($betaUserServiceSetEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceSetEmailRequest when calling setEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/SetEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceSetEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceSetEmailRequest));
            } else {
                $httpBody = $betaUserServiceSetEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPassword
     *
     * SetPassword
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetPasswordRequest $betaUserServiceSetPasswordRequest betaUserServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPassword'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceSetPasswordResponse
     * @throws ApiException
     */
    public function setPassword(    $betaUserServiceSetPasswordRequest,string $contentType = self::contentTypes['setPassword'][0])
    {
        $request = $this->setPasswordRequest($betaUserServiceSetPasswordRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceSetPasswordResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceSetPasswordResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setPassword'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetPasswordRequest $betaUserServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setPasswordRequest($betaUserServiceSetPasswordRequest, string $contentType = self::contentTypes['setPassword'][0])
    {

        if ($betaUserServiceSetPasswordRequest === null || (is_array($betaUserServiceSetPasswordRequest) && count($betaUserServiceSetPasswordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceSetPasswordRequest when calling setPassword'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/SetPassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceSetPasswordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceSetPasswordRequest));
            } else {
                $httpBody = $betaUserServiceSetPasswordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPhone
     *
     * SetPhone
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetPhoneRequest $betaUserServiceSetPhoneRequest betaUserServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceSetPhoneResponse
     * @throws ApiException
     */
    public function setPhone(    $betaUserServiceSetPhoneRequest,string $contentType = self::contentTypes['setPhone'][0])
    {
        $request = $this->setPhoneRequest($betaUserServiceSetPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceSetPhoneResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceSetPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setPhone'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceSetPhoneRequest $betaUserServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setPhoneRequest($betaUserServiceSetPhoneRequest, string $contentType = self::contentTypes['setPhone'][0])
    {

        if ($betaUserServiceSetPhoneRequest === null || (is_array($betaUserServiceSetPhoneRequest) && count($betaUserServiceSetPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceSetPhoneRequest when calling setPhone'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/SetPhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceSetPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceSetPhoneRequest));
            } else {
                $httpBody = $betaUserServiceSetPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startIdentityProviderIntent
     *
     * StartIdentityProviderIntent
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceStartIdentityProviderIntentRequest $betaUserServiceStartIdentityProviderIntentRequest betaUserServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceStartIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function startIdentityProviderIntent(    $betaUserServiceStartIdentityProviderIntentRequest,string $contentType = self::contentTypes['startIdentityProviderIntent'][0])
    {
        $request = $this->startIdentityProviderIntentRequest($betaUserServiceStartIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceStartIdentityProviderIntentResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceStartIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'startIdentityProviderIntent'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceStartIdentityProviderIntentRequest $betaUserServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function startIdentityProviderIntentRequest($betaUserServiceStartIdentityProviderIntentRequest, string $contentType = self::contentTypes['startIdentityProviderIntent'][0])
    {

        if ($betaUserServiceStartIdentityProviderIntentRequest === null || (is_array($betaUserServiceStartIdentityProviderIntentRequest) && count($betaUserServiceStartIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceStartIdentityProviderIntentRequest when calling startIdentityProviderIntent'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/StartIdentityProviderIntent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceStartIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceStartIdentityProviderIntentRequest));
            } else {
                $httpBody = $betaUserServiceStartIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockUser
     *
     * UnlockUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceUnlockUserRequest $betaUserServiceUnlockUserRequest betaUserServiceUnlockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceUnlockUserResponse
     * @throws ApiException
     */
    public function unlockUser(    $betaUserServiceUnlockUserRequest,string $contentType = self::contentTypes['unlockUser'][0])
    {
        $request = $this->unlockUserRequest($betaUserServiceUnlockUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceUnlockUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceUnlockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'unlockUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceUnlockUserRequest $betaUserServiceUnlockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function unlockUserRequest($betaUserServiceUnlockUserRequest, string $contentType = self::contentTypes['unlockUser'][0])
    {

        if ($betaUserServiceUnlockUserRequest === null || (is_array($betaUserServiceUnlockUserRequest) && count($betaUserServiceUnlockUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceUnlockUserRequest when calling unlockUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/UnlockUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceUnlockUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceUnlockUserRequest));
            } else {
                $httpBody = $betaUserServiceUnlockUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHumanUser
     *
     * UpdateHumanUser
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceUpdateHumanUserRequest $betaUserServiceUpdateHumanUserRequest betaUserServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceUpdateHumanUserResponse
     * @throws ApiException
     */
    public function updateHumanUser(    $betaUserServiceUpdateHumanUserRequest,string $contentType = self::contentTypes['updateHumanUser'][0])
    {
        $request = $this->updateHumanUserRequest($betaUserServiceUpdateHumanUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceUpdateHumanUserResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceUpdateHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'updateHumanUser'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceUpdateHumanUserRequest $betaUserServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function updateHumanUserRequest($betaUserServiceUpdateHumanUserRequest, string $contentType = self::contentTypes['updateHumanUser'][0])
    {

        if ($betaUserServiceUpdateHumanUserRequest === null || (is_array($betaUserServiceUpdateHumanUserRequest) && count($betaUserServiceUpdateHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceUpdateHumanUserRequest when calling updateHumanUser'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/UpdateHumanUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceUpdateHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceUpdateHumanUserRequest));
            } else {
                $httpBody = $betaUserServiceUpdateHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyEmail
     *
     * VerifyEmail
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyEmailRequest $betaUserServiceVerifyEmailRequest betaUserServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceVerifyEmailResponse
     * @throws ApiException
     */
    public function verifyEmail(    $betaUserServiceVerifyEmailRequest,string $contentType = self::contentTypes['verifyEmail'][0])
    {
        $request = $this->verifyEmailRequest($betaUserServiceVerifyEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceVerifyEmailResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceVerifyEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyEmail'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyEmailRequest $betaUserServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyEmailRequest($betaUserServiceVerifyEmailRequest, string $contentType = self::contentTypes['verifyEmail'][0])
    {

        if ($betaUserServiceVerifyEmailRequest === null || (is_array($betaUserServiceVerifyEmailRequest) && count($betaUserServiceVerifyEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceVerifyEmailRequest when calling verifyEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/VerifyEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceVerifyEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceVerifyEmailRequest));
            } else {
                $httpBody = $betaUserServiceVerifyEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyPasskeyRegistration
     *
     * VerifyPasskeyRegistration
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyPasskeyRegistrationRequest $betaUserServiceVerifyPasskeyRegistrationRequest betaUserServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceVerifyPasskeyRegistrationResponse
     * @throws ApiException
     */
    public function verifyPasskeyRegistration(    $betaUserServiceVerifyPasskeyRegistrationRequest,string $contentType = self::contentTypes['verifyPasskeyRegistration'][0])
    {
        $request = $this->verifyPasskeyRegistrationRequest($betaUserServiceVerifyPasskeyRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceVerifyPasskeyRegistrationResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceVerifyPasskeyRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyPasskeyRegistration'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyPasskeyRegistrationRequest $betaUserServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyPasskeyRegistrationRequest($betaUserServiceVerifyPasskeyRegistrationRequest, string $contentType = self::contentTypes['verifyPasskeyRegistration'][0])
    {

        if ($betaUserServiceVerifyPasskeyRegistrationRequest === null || (is_array($betaUserServiceVerifyPasskeyRegistrationRequest) && count($betaUserServiceVerifyPasskeyRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceVerifyPasskeyRegistrationRequest when calling verifyPasskeyRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/VerifyPasskeyRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceVerifyPasskeyRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceVerifyPasskeyRegistrationRequest));
            } else {
                $httpBody = $betaUserServiceVerifyPasskeyRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyPhone
     *
     * VerifyPhone
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyPhoneRequest $betaUserServiceVerifyPhoneRequest betaUserServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceVerifyPhoneResponse
     * @throws ApiException
     */
    public function verifyPhone(    $betaUserServiceVerifyPhoneRequest,string $contentType = self::contentTypes['verifyPhone'][0])
    {
        $request = $this->verifyPhoneRequest($betaUserServiceVerifyPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceVerifyPhoneResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceVerifyPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyPhone'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyPhoneRequest $betaUserServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyPhoneRequest($betaUserServiceVerifyPhoneRequest, string $contentType = self::contentTypes['verifyPhone'][0])
    {

        if ($betaUserServiceVerifyPhoneRequest === null || (is_array($betaUserServiceVerifyPhoneRequest) && count($betaUserServiceVerifyPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceVerifyPhoneRequest when calling verifyPhone'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/VerifyPhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceVerifyPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceVerifyPhoneRequest));
            } else {
                $httpBody = $betaUserServiceVerifyPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyTOTPRegistration
     *
     * VerifyTOTPRegistration
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyTOTPRegistrationRequest $betaUserServiceVerifyTOTPRegistrationRequest betaUserServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyTOTPRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceVerifyTOTPRegistrationResponse
     * @throws ApiException
     */
    public function verifyTOTPRegistration(    $betaUserServiceVerifyTOTPRegistrationRequest,string $contentType = self::contentTypes['verifyTOTPRegistration'][0])
    {
        $request = $this->verifyTOTPRegistrationRequest($betaUserServiceVerifyTOTPRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceVerifyTOTPRegistrationResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceVerifyTOTPRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyTOTPRegistration'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyTOTPRegistrationRequest $betaUserServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyTOTPRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyTOTPRegistrationRequest($betaUserServiceVerifyTOTPRegistrationRequest, string $contentType = self::contentTypes['verifyTOTPRegistration'][0])
    {

        if ($betaUserServiceVerifyTOTPRegistrationRequest === null || (is_array($betaUserServiceVerifyTOTPRegistrationRequest) && count($betaUserServiceVerifyTOTPRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceVerifyTOTPRegistrationRequest when calling verifyTOTPRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/VerifyTOTPRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceVerifyTOTPRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceVerifyTOTPRegistrationRequest));
            } else {
                $httpBody = $betaUserServiceVerifyTOTPRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyU2FRegistration
     *
     * VerifyU2FRegistration
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyU2FRegistrationRequest $betaUserServiceVerifyU2FRegistrationRequest betaUserServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyU2FRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\BetaUserServiceVerifyU2FRegistrationResponse
     * @throws ApiException
     */
    public function verifyU2FRegistration(    $betaUserServiceVerifyU2FRegistrationRequest,string $contentType = self::contentTypes['verifyU2FRegistration'][0])
    {
        $request = $this->verifyU2FRegistrationRequest($betaUserServiceVerifyU2FRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\BetaUserServiceVerifyU2FRegistrationResponse',
            'default' => '\Zitadel\Client\Model\BetaUserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\BetaUserServiceVerifyU2FRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyU2FRegistration'
     *
     * @param  \Zitadel\Client\Model\BetaUserServiceVerifyU2FRegistrationRequest $betaUserServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyU2FRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyU2FRegistrationRequest($betaUserServiceVerifyU2FRegistrationRequest, string $contentType = self::contentTypes['verifyU2FRegistration'][0])
    {

        if ($betaUserServiceVerifyU2FRegistrationRequest === null || (is_array($betaUserServiceVerifyU2FRegistrationRequest) && count($betaUserServiceVerifyU2FRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $betaUserServiceVerifyU2FRegistrationRequest when calling verifyU2FRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2beta.UserService/VerifyU2FRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($betaUserServiceVerifyU2FRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($betaUserServiceVerifyU2FRegistrationRequest));
            } else {
                $httpBody = $betaUserServiceVerifyU2FRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
