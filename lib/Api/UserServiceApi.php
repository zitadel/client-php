<?php
/**
 * UserServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zitadel SDK
 *
 * The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Zitadel\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zitadel\Client\ApiException;
use Zitadel\Client\Configuration;
use Zitadel\Client\ObjectSerializer;
use RuntimeException;
use Exception;

/**
 * UserServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'userServiceAddHumanUser' => [
            'application/json',
        ],
        'userServiceAddIDPLink' => [
            'application/json',
        ],
        'userServiceAddOTPEmail' => [
            'application/json',
        ],
        'userServiceAddOTPSMS' => [
            'application/json',
        ],
        'userServiceCreateInviteCode' => [
            'application/json',
        ],
        'userServiceCreatePasskeyRegistrationLink' => [
            'application/json',
        ],
        'userServiceDeactivateUser' => [
            'application/json',
        ],
        'userServiceDeleteUser' => [
            'application/json',
        ],
        'userServiceGetUserByID' => [
            'application/json',
        ],
        'userServiceHumanMFAInitSkipped' => [
            'application/json',
        ],
        'userServiceListAuthenticationFactors' => [
            'application/json',
        ],
        'userServiceListAuthenticationMethodTypes' => [
            'application/json',
        ],
        'userServiceListIDPLinks' => [
            'application/json',
        ],
        'userServiceListPasskeys' => [
            'application/json',
        ],
        'userServiceListUsers' => [
            'application/json',
        ],
        'userServiceLockUser' => [
            'application/json',
        ],
        'userServicePasswordReset' => [
            'application/json',
        ],
        'userServiceReactivateUser' => [
            'application/json',
        ],
        'userServiceRegisterPasskey' => [
            'application/json',
        ],
        'userServiceRegisterTOTP' => [
            'application/json',
        ],
        'userServiceRegisterU2F' => [
            'application/json',
        ],
        'userServiceRemoveIDPLink' => [
            'application/json',
        ],
        'userServiceRemoveOTPEmail' => [
            'application/json',
        ],
        'userServiceRemoveOTPSMS' => [
            'application/json',
        ],
        'userServiceRemovePasskey' => [
            'application/json',
        ],
        'userServiceRemovePhone' => [
            'application/json',
        ],
        'userServiceRemoveTOTP' => [
            'application/json',
        ],
        'userServiceRemoveU2F' => [
            'application/json',
        ],
        'userServiceResendEmailCode' => [
            'application/json',
        ],
        'userServiceResendInviteCode' => [
            'application/json',
        ],
        'userServiceResendPhoneCode' => [
            'application/json',
        ],
        'userServiceRetrieveIdentityProviderIntent' => [
            'application/json',
        ],
        'userServiceSendEmailCode' => [
            'application/json',
        ],
        'userServiceSetEmail' => [
            'application/json',
        ],
        'userServiceSetPassword' => [
            'application/json',
        ],
        'userServiceSetPhone' => [
            'application/json',
        ],
        'userServiceStartIdentityProviderIntent' => [
            'application/json',
        ],
        'userServiceUnlockUser' => [
            'application/json',
        ],
        'userServiceUpdateHumanUser' => [
            'application/json',
        ],
        'userServiceVerifyEmail' => [
            'application/json',
        ],
        'userServiceVerifyInviteCode' => [
            'application/json',
        ],
        'userServiceVerifyPasskeyRegistration' => [
            'application/json',
        ],
        'userServiceVerifyPhone' => [
            'application/json',
        ],
        'userServiceVerifyTOTPRegistration' => [
            'application/json',
        ],
        'userServiceVerifyU2FRegistration' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        Configuration $config = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client([
            'http_errors' => false,
        ]);
        $this->config = $config;
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param string[] $accept
     * @param string $contentType
     * @param bool $isMultipart
     * @return string[]
     */
    private function selectHeaders(array $accept, string $contentType, bool $isMultipart): array
    {
        $headers = [];

        $accept = $this->selectAcceptHeader($accept);
        if ($accept !== null) {
            $headers['Accept'] = $accept;
        }

        if (!$isMultipart) {
            if ($contentType === '') {
                $contentType = 'application/json';
            }

            $headers['Content-Type'] = $contentType;
        }

        return $headers;
    }

    /**
     * Return the header 'Accept' based on an array of Accept provided.
     *
     * @param string[] $accept Array of header
     *
     * @return null|string Accept (e.g. application/json)
     */
    private function selectAcceptHeader(array $accept): ?string
    {
        # filter out empty entries
        $accept = array_filter($accept);

        if (count($accept) === 0) {
            return null;
        }

        # If there's only one Accept header, just use it
        if (count($accept) === 1) {
            return reset($accept);
        }

        # If none of the available Accept headers is of type "json", then just use all them
        $headersWithJson = $this->selectJsonMimeList($accept);
        if (count($headersWithJson) === 0) {
            return implode(',', $accept);
        }

        # If we got here, then we need add quality values (weight), as described in IETF RFC 9110, Items 12.4.2/12.5.1,
        # to give the highest priority to json-like headers - recalculating the existing ones, if needed
        return $this->getAcceptHeaderWithAdjustedWeight($accept, $headersWithJson);
    }

    /**
     * Select all items from a list containing a JSON mime type
     *
     * @param array $mimeList
     * @return array
     */
    private function selectJsonMimeList(array $mimeList): array
    {
        $jsonMimeList = [];
        foreach ($mimeList as $mime) {
            if ($this->isJsonMime($mime)) {
                $jsonMimeList[] = $mime;
            }
        }
        return $jsonMimeList;
    }

    /**
     * Detects whether a string contains a valid JSON mime type
     *
     * @param string $searchString
     * @return bool
     */
    private function isJsonMime(string $searchString): bool
    {
        /** @noinspection PhpCoveredCharacterInClassInspection */
        return preg_match('~^application/(json|[\w!#$&.+-^_]+\+json)\s*(;|$)~', $searchString) === 1;
    }

    /**
     * Create an Accept header string from the given "Accept" headers array, recalculating all weights
     *
     * @param string[] $accept Array of Accept Headers
     * @param string[] $headersWithJson Array of Accept Headers of type "json"
     *
     * @return string "Accept" Header (e.g. "application/json, text/html; q=0.9")
     */
    private function getAcceptHeaderWithAdjustedWeight(array $accept, array $headersWithJson): string
    {
        $processedHeaders = [
          'withApplicationJson' => [],
          'withJson' => [],
          'withoutJson' => [],
        ];

        foreach ($accept as $header) {

            $headerData = $this->getHeaderAndWeight($header);

            if (stripos($headerData['header'], 'application/json') === 0) {
                $processedHeaders['withApplicationJson'][] = $headerData;
            } elseif (in_array($header, $headersWithJson, true)) {
                $processedHeaders['withJson'][] = $headerData;
            } else {
                $processedHeaders['withoutJson'][] = $headerData;
            }
        }

        $acceptHeaders = [];
        $currentWeight = 1000;

        $hasMoreThan28Headers = count($accept) > 28;

        foreach ($processedHeaders as $headers) {
            if (count($headers) > 0) {
                $acceptHeaders[] = $this->adjustWeight($headers, $currentWeight, $hasMoreThan28Headers);
            }
        }

        $acceptHeaders = array_merge(...$acceptHeaders);

        return implode(',', $acceptHeaders);
    }

    /**
     * Given an Accept header, returns an associative array splitting the header and its weight
     *
     * @param string $header "Accept" Header
     *
     * @return array with the header and its weight
     */
    private function getHeaderAndWeight(string $header): array
    {
        # matches headers with weight, splitting the header and the weight in $outputArray
        if (preg_match('/(.*);\s*q=(1(?:\.0+)?|0\.\d+)$/', $header, $outputArray) === 1) {
            $headerData = [
              'header' => $outputArray[1],
              'weight' => (int)($outputArray[2] * 1000),
            ];
        } else {
            $headerData = [
              'header' => trim($header),
              'weight' => 1000,
            ];
        }

        return $headerData;
    }

    /**
     * @param array[] $headers
     * @param float $currentWeight
     * @param bool $hasMoreThan28Headers
     * @return string[] array of adjusted "Accept" headers
     */
    private function adjustWeight(array $headers, float &$currentWeight, bool $hasMoreThan28Headers): array
    {
        usort($headers, fn (array $a, array $b) => $b['weight'] - $a['weight']);

        $acceptHeaders = [];
        foreach ($headers as $index => $header) {
            if ($index > 0 && $headers[$index - 1]['weight'] > $header['weight']) {
                $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);
            }

            $weight = $currentWeight;

            $acceptHeaders[] = $this->buildAcceptHeader($header['header'], $weight);
        }

        $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);

        return $acceptHeaders;
    }

    /**
     * Calculate the next weight, based on the current one.
     *
     * If there are less than 28 "Accept" headers, the weights will be decreased by 1 on its highest significant digit, using the
     * following formula:
     *
     *    next weight = current weight - 10 ^ (floor(log(current weight - 1)))
     *
     *    ( current weight minus ( 10 raised to the power of ( floor of (log to the base 10 of ( current weight minus 1 ) ) ) ) )
     *
     * Starting from 1000, this generates the following series:
     *
     * 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
     *
     * The resulting quality codes are closer to the average "normal" usage of them (like "q=0.9", "q=0.8" and so on), but it only works
     * if there is a maximum of 28 "Accept" headers. If we have more than that (which is extremely unlikely), then we fall back to a 1-by-1
     * decrement rule, which will result in quality codes like "q=0.999", "q=0.998" etc.
     *
     * @param int $currentWeight varying from 1 to 1000 (will be divided by 1000 to build the quality value)
     * @param bool $hasMoreThan28Headers
     * @return int
     */
    private function getNextWeight(int $currentWeight, bool $hasMoreThan28Headers): int
    {
        if ($currentWeight <= 1) {
            return 1;
        }

        if ($hasMoreThan28Headers) {
            return $currentWeight - 1;
        }

        return $currentWeight - 10 ** floor(log10($currentWeight - 1));
    }

    /**
     * @param string $header
     * @param int $weight
     * @return string
     */
    private function buildAcceptHeader(string $header, int $weight): string
    {
        if ($weight === 1000) {
            return $header;
        }

        return trim($header, '; ') . ';q=' . rtrim(sprintf('%0.3f', $weight / 1000), '0');
    }


        /**
     * @throws ApiException
     */
    private function executeRequest(
        Request $request,
        array $responseTypes,
        string $defaultResponseType
    ): mixed {
        try {
            $options = $this->createHttpClientOption();
            $response = $this->client->send($request, $options);
        } catch (GuzzleException $e) {
            throw new RuntimeException(
                "API Request failed: [{$e->getCode()}] {$e->getMessage()}",
                (int) $e->getCode(),
                $e
            );
        }

        $statusCode = $response->getStatusCode();
        $responseBody = $response->getBody();
        $responseHeaders = $response->getHeaders();

        if ($statusCode >= 200 && $statusCode < 300) {
            $returnType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($returnType === '\SplFileObject') {
                return $responseBody;
            } else {
                $content = (string) $responseBody;

                if (empty(trim($content)) && $returnType !== 'string') {
                    $content = null;
                }

                try {
                    return ObjectSerializer::deserialize($content, $returnType, $this->config, []);
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process successful response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            }
        } else {
            $errorType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($errorType === '\SplFileObject') {
                throw new ApiException(
                    sprintf('[%d] API Error (%s) - Expected file object', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            } elseif ($errorType !== 'string' && !empty(trim((string) $responseBody))) {
                try {
                    $decodedContent = json_decode((string)$responseBody, false, 512, JSON_THROW_ON_ERROR);
                    throw new ApiException(
                        sprintf('[%d] API Error (%s)', $statusCode, (string)$request->getUri()),
                        $statusCode,
                        $responseHeaders,
                        $decodedContent,
                    );
                } catch (ApiException $e) {
                    throw $e;
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process error response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            } else {
                throw new ApiException(
                    sprintf('[%d] API Error (%s)', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            }
        }
    }

    /**
     * Operation userServiceAddHumanUser
     *
     * Create a new human user
     *
     * @param  \Zitadel\Client\Model\UserServiceAddHumanUserRequest $userServiceAddHumanUserRequest userServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddHumanUserResponse
     * @throws ApiException
     */
    public function userServiceAddHumanUser($userServiceAddHumanUserRequest, string $contentType = self::contentTypes['userServiceAddHumanUser'][0])
    {
        $request = $this->userServiceAddHumanUserRequest($userServiceAddHumanUserRequest, $contentType);

        $responseTypes = [
            201 => '\Zitadel\Client\Model\UserServiceAddHumanUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceAddHumanUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddHumanUserRequest $userServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceAddHumanUserRequest($userServiceAddHumanUserRequest, string $contentType = self::contentTypes['userServiceAddHumanUser'][0])
    {

        if ($userServiceAddHumanUserRequest === null || (is_array($userServiceAddHumanUserRequest) && count($userServiceAddHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddHumanUserRequest when calling userServiceAddHumanUser'
            );
        }


        $resourcePath = '/v2/users/human';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddHumanUserRequest));
            } else {
                $httpBody = $userServiceAddHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceAddIDPLink
     *
     * Add link to an identity provider to an user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceAddIDPLinkRequest $userServiceAddIDPLinkRequest userServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddIDPLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddIDPLinkResponse
     * @throws ApiException
     */
    public function userServiceAddIDPLink($userId, $userServiceAddIDPLinkRequest, string $contentType = self::contentTypes['userServiceAddIDPLink'][0])
    {
        $request = $this->userServiceAddIDPLinkRequest($userId, $userServiceAddIDPLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddIDPLinkResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddIDPLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceAddIDPLink'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceAddIDPLinkRequest $userServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddIDPLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceAddIDPLinkRequest($userId, $userServiceAddIDPLinkRequest, string $contentType = self::contentTypes['userServiceAddIDPLink'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceAddIDPLink'
            );
        }

        if ($userServiceAddIDPLinkRequest === null || (is_array($userServiceAddIDPLinkRequest) && count($userServiceAddIDPLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddIDPLinkRequest when calling userServiceAddIDPLink'
            );
        }


        $resourcePath = '/v2/users/{userId}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddIDPLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddIDPLinkRequest));
            } else {
                $httpBody = $userServiceAddIDPLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceAddOTPEmail
     *
     * Add OTP Email for a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddOTPEmailResponse
     * @throws ApiException
     */
    public function userServiceAddOTPEmail($userId, string $contentType = self::contentTypes['userServiceAddOTPEmail'][0])
    {
        $request = $this->userServiceAddOTPEmailRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddOTPEmailResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceAddOTPEmail'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceAddOTPEmailRequest($userId, string $contentType = self::contentTypes['userServiceAddOTPEmail'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceAddOTPEmail'
            );
        }


        $resourcePath = '/v2/users/{userId}/otp_email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceAddOTPSMS
     *
     * Add OTP SMS for a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddOTPSMSResponse
     * @throws ApiException
     */
    public function userServiceAddOTPSMS($userId, string $contentType = self::contentTypes['userServiceAddOTPSMS'][0])
    {
        $request = $this->userServiceAddOTPSMSRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddOTPSMSResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceAddOTPSMS'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceAddOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceAddOTPSMSRequest($userId, string $contentType = self::contentTypes['userServiceAddOTPSMS'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceAddOTPSMS'
            );
        }


        $resourcePath = '/v2/users/{userId}/otp_sms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceCreateInviteCode
     *
     * Create an invite code for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceCreateInviteCodeRequest $userServiceCreateInviteCodeRequest userServiceCreateInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceCreateInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceCreateInviteCodeResponse
     * @throws ApiException
     */
    public function userServiceCreateInviteCode($userId, $userServiceCreateInviteCodeRequest, string $contentType = self::contentTypes['userServiceCreateInviteCode'][0])
    {
        $request = $this->userServiceCreateInviteCodeRequest($userId, $userServiceCreateInviteCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceCreateInviteCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceCreateInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceCreateInviteCode'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceCreateInviteCodeRequest $userServiceCreateInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceCreateInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceCreateInviteCodeRequest($userId, $userServiceCreateInviteCodeRequest, string $contentType = self::contentTypes['userServiceCreateInviteCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceCreateInviteCode'
            );
        }

        if ($userServiceCreateInviteCodeRequest === null || (is_array($userServiceCreateInviteCodeRequest) && count($userServiceCreateInviteCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceCreateInviteCodeRequest when calling userServiceCreateInviteCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/invite_code';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceCreateInviteCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceCreateInviteCodeRequest));
            } else {
                $httpBody = $userServiceCreateInviteCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceCreatePasskeyRegistrationLink
     *
     * Create a passkey registration link for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkRequest $userServiceCreatePasskeyRegistrationLinkRequest userServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceCreatePasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse
     * @throws ApiException
     */
    public function userServiceCreatePasskeyRegistrationLink($userId, $userServiceCreatePasskeyRegistrationLinkRequest, string $contentType = self::contentTypes['userServiceCreatePasskeyRegistrationLink'][0])
    {
        $request = $this->userServiceCreatePasskeyRegistrationLinkRequest($userId, $userServiceCreatePasskeyRegistrationLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceCreatePasskeyRegistrationLink'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkRequest $userServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceCreatePasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceCreatePasskeyRegistrationLinkRequest($userId, $userServiceCreatePasskeyRegistrationLinkRequest, string $contentType = self::contentTypes['userServiceCreatePasskeyRegistrationLink'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceCreatePasskeyRegistrationLink'
            );
        }

        if ($userServiceCreatePasskeyRegistrationLinkRequest === null || (is_array($userServiceCreatePasskeyRegistrationLinkRequest) && count($userServiceCreatePasskeyRegistrationLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceCreatePasskeyRegistrationLinkRequest when calling userServiceCreatePasskeyRegistrationLink'
            );
        }


        $resourcePath = '/v2/users/{userId}/passkeys/registration_link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceCreatePasskeyRegistrationLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceCreatePasskeyRegistrationLinkRequest));
            } else {
                $httpBody = $userServiceCreatePasskeyRegistrationLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceDeactivateUser
     *
     * Deactivate user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceDeactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceDeactivateUserResponse
     * @throws ApiException
     */
    public function userServiceDeactivateUser($userId, string $contentType = self::contentTypes['userServiceDeactivateUser'][0])
    {
        $request = $this->userServiceDeactivateUserRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceDeactivateUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceDeactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceDeactivateUser'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceDeactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceDeactivateUserRequest($userId, string $contentType = self::contentTypes['userServiceDeactivateUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceDeactivateUser'
            );
        }


        $resourcePath = '/v2/users/{userId}/deactivate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceDeleteUser
     *
     * Delete user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceDeleteUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceDeleteUserResponse
     * @throws ApiException
     */
    public function userServiceDeleteUser($userId, string $contentType = self::contentTypes['userServiceDeleteUser'][0])
    {
        $request = $this->userServiceDeleteUserRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceDeleteUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceDeleteUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceDeleteUser'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceDeleteUserRequest($userId, string $contentType = self::contentTypes['userServiceDeleteUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceDeleteUser'
            );
        }


        $resourcePath = '/v2/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceGetUserByID
     *
     * User by ID
     *
     * @param  string $userId User ID of the user you like to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceGetUserByID'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceGetUserByIDResponse
     * @throws ApiException
     */
    public function userServiceGetUserByID($userId, string $contentType = self::contentTypes['userServiceGetUserByID'][0])
    {
        $request = $this->userServiceGetUserByIDRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceGetUserByIDResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceGetUserByIDResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceGetUserByID'
     *
     * @param  string $userId User ID of the user you like to get. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceGetUserByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceGetUserByIDRequest($userId, string $contentType = self::contentTypes['userServiceGetUserByID'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceGetUserByID'
            );
        }


        $resourcePath = '/v2/users/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceHumanMFAInitSkipped
     *
     * MFA Init Skipped
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceHumanMFAInitSkipped'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse
     * @throws ApiException
     */
    public function userServiceHumanMFAInitSkipped($userId, string $contentType = self::contentTypes['userServiceHumanMFAInitSkipped'][0])
    {
        $request = $this->userServiceHumanMFAInitSkippedRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceHumanMFAInitSkipped'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceHumanMFAInitSkipped'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceHumanMFAInitSkippedRequest($userId, string $contentType = self::contentTypes['userServiceHumanMFAInitSkipped'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceHumanMFAInitSkipped'
            );
        }


        $resourcePath = '/v2/users/{userId}/mfa_init_skipped';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceListAuthenticationFactors
     *
     * @param  string $userId userId (required)
     * @param  string[]|null $authFactors Specify the Auth Factors you are interested in (optional)
     * @param  string[]|null $states Specify the state of the Auth Factors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListAuthenticationFactors'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse
     * @throws ApiException
     */
    public function userServiceListAuthenticationFactors($userId, $authFactors = null, $states = null, string $contentType = self::contentTypes['userServiceListAuthenticationFactors'][0])
    {
        $request = $this->userServiceListAuthenticationFactorsRequest($userId, $authFactors, $states, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceListAuthenticationFactors'
     *
     * @param  string $userId (required)
     * @param  string[]|null $authFactors Specify the Auth Factors you are interested in (optional)
     * @param  string[]|null $states Specify the state of the Auth Factors (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListAuthenticationFactors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceListAuthenticationFactorsRequest($userId, $authFactors = null, $states = null, string $contentType = self::contentTypes['userServiceListAuthenticationFactors'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceListAuthenticationFactors'
            );
        }




        $resourcePath = '/v2/users/{userId}/authentication_factors/_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $authFactors,
            'authFactors', // param base name
            $this->config->getBooleanFormatForQueryString(),
            'array', // openApiType
            '', // style
            true, // explode
            false // required
        ) ?? []);
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $states,
            'states', // param base name
            $this->config->getBooleanFormatForQueryString(),
            'array', // openApiType
            '', // style
            true, // explode
            false // required
        ) ?? []);


        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceListAuthenticationMethodTypes
     *
     * List all possible authentication methods of a user
     *
     * @param  string $userId userId (required)
     * @param  bool|null $domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
     * @param  string|null $domainQueryDomain List only auth methods with specific domain. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse
     * @throws ApiException
     */
    public function userServiceListAuthenticationMethodTypes($userId, $domainQueryIncludeWithoutDomain = null, $domainQueryDomain = null, string $contentType = self::contentTypes['userServiceListAuthenticationMethodTypes'][0])
    {
        $request = $this->userServiceListAuthenticationMethodTypesRequest($userId, $domainQueryIncludeWithoutDomain, $domainQueryDomain, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceListAuthenticationMethodTypes'
     *
     * @param  string $userId (required)
     * @param  bool|null $domainQueryIncludeWithoutDomain List also auth method types without domain information like passkey and U2F added through V1 APIs / Login UI. (optional)
     * @param  string|null $domainQueryDomain List only auth methods with specific domain. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceListAuthenticationMethodTypesRequest($userId, $domainQueryIncludeWithoutDomain = null, $domainQueryDomain = null, string $contentType = self::contentTypes['userServiceListAuthenticationMethodTypes'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceListAuthenticationMethodTypes'
            );
        }




        $resourcePath = '/v2/users/{userId}/authentication_methods';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domainQueryIncludeWithoutDomain,
            'domainQuery.includeWithoutDomain', // param base name
            $this->config->getBooleanFormatForQueryString(),
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domainQueryDomain,
            'domainQuery.domain', // param base name
            $this->config->getBooleanFormatForQueryString(),
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceListIDPLinks
     *
     * List links to an identity provider of an user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceListIDPLinksRequest $userServiceListIDPLinksRequest userServiceListIDPLinksRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListIDPLinks'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListIDPLinksResponse
     * @throws ApiException
     */
    public function userServiceListIDPLinks($userId, $userServiceListIDPLinksRequest, string $contentType = self::contentTypes['userServiceListIDPLinks'][0])
    {
        $request = $this->userServiceListIDPLinksRequest($userId, $userServiceListIDPLinksRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListIDPLinksResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListIDPLinksResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceListIDPLinks'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceListIDPLinksRequest $userServiceListIDPLinksRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListIDPLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceListIDPLinksRequest($userId, $userServiceListIDPLinksRequest, string $contentType = self::contentTypes['userServiceListIDPLinks'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceListIDPLinks'
            );
        }

        if ($userServiceListIDPLinksRequest === null || (is_array($userServiceListIDPLinksRequest) && count($userServiceListIDPLinksRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListIDPLinksRequest when calling userServiceListIDPLinks'
            );
        }


        $resourcePath = '/v2/users/{userId}/links/_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListIDPLinksRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListIDPLinksRequest));
            } else {
                $httpBody = $userServiceListIDPLinksRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceListPasskeys
     *
     * List passkeys of an user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListPasskeys'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListPasskeysResponse
     * @throws ApiException
     */
    public function userServiceListPasskeys($userId, string $contentType = self::contentTypes['userServiceListPasskeys'][0])
    {
        $request = $this->userServiceListPasskeysRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListPasskeysResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListPasskeysResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceListPasskeys'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListPasskeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceListPasskeysRequest($userId, string $contentType = self::contentTypes['userServiceListPasskeys'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceListPasskeys'
            );
        }


        $resourcePath = '/v2/users/{userId}/passkeys/_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceListUsers
     *
     * Search Users
     *
     * @param  \Zitadel\Client\Model\UserServiceListUsersRequest $userServiceListUsersRequest userServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListUsers'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListUsersResponse
     * @throws ApiException
     */
    public function userServiceListUsers($userServiceListUsersRequest, string $contentType = self::contentTypes['userServiceListUsers'][0])
    {
        $request = $this->userServiceListUsersRequest($userServiceListUsersRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListUsersResponse',
            400 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListUsersResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceListUsers'
     *
     * @param  \Zitadel\Client\Model\UserServiceListUsersRequest $userServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceListUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceListUsersRequest($userServiceListUsersRequest, string $contentType = self::contentTypes['userServiceListUsers'][0])
    {

        if ($userServiceListUsersRequest === null || (is_array($userServiceListUsersRequest) && count($userServiceListUsersRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListUsersRequest when calling userServiceListUsers'
            );
        }


        $resourcePath = '/v2/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListUsersRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListUsersRequest));
            } else {
                $httpBody = $userServiceListUsersRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceLockUser
     *
     * Lock user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceLockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceLockUserResponse
     * @throws ApiException
     */
    public function userServiceLockUser($userId, string $contentType = self::contentTypes['userServiceLockUser'][0])
    {
        $request = $this->userServiceLockUserRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceLockUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceLockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceLockUser'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceLockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceLockUserRequest($userId, string $contentType = self::contentTypes['userServiceLockUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceLockUser'
            );
        }


        $resourcePath = '/v2/users/{userId}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServicePasswordReset
     *
     * Request a code to reset a password
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServicePasswordResetRequest $userServicePasswordResetRequest userServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServicePasswordReset'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServicePasswordResetResponse
     * @throws ApiException
     */
    public function userServicePasswordReset($userId, $userServicePasswordResetRequest, string $contentType = self::contentTypes['userServicePasswordReset'][0])
    {
        $request = $this->userServicePasswordResetRequest($userId, $userServicePasswordResetRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServicePasswordResetResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServicePasswordResetResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServicePasswordReset'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServicePasswordResetRequest $userServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServicePasswordReset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServicePasswordResetRequest($userId, $userServicePasswordResetRequest, string $contentType = self::contentTypes['userServicePasswordReset'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServicePasswordReset'
            );
        }

        if ($userServicePasswordResetRequest === null || (is_array($userServicePasswordResetRequest) && count($userServicePasswordResetRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServicePasswordResetRequest when calling userServicePasswordReset'
            );
        }


        $resourcePath = '/v2/users/{userId}/password_reset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServicePasswordResetRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServicePasswordResetRequest));
            } else {
                $httpBody = $userServicePasswordResetRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceReactivateUser
     *
     * Reactivate user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceReactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceReactivateUserResponse
     * @throws ApiException
     */
    public function userServiceReactivateUser($userId, string $contentType = self::contentTypes['userServiceReactivateUser'][0])
    {
        $request = $this->userServiceReactivateUserRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceReactivateUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceReactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceReactivateUser'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceReactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceReactivateUserRequest($userId, string $contentType = self::contentTypes['userServiceReactivateUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceReactivateUser'
            );
        }


        $resourcePath = '/v2/users/{userId}/reactivate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRegisterPasskey
     *
     * Start the registration of passkey for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceRegisterPasskeyRequest $userServiceRegisterPasskeyRequest userServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterPasskey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterPasskeyResponse
     * @throws ApiException
     */
    public function userServiceRegisterPasskey($userId, $userServiceRegisterPasskeyRequest, string $contentType = self::contentTypes['userServiceRegisterPasskey'][0])
    {
        $request = $this->userServiceRegisterPasskeyRequest($userId, $userServiceRegisterPasskeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterPasskeyResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterPasskeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRegisterPasskey'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceRegisterPasskeyRequest $userServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterPasskey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRegisterPasskeyRequest($userId, $userServiceRegisterPasskeyRequest, string $contentType = self::contentTypes['userServiceRegisterPasskey'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRegisterPasskey'
            );
        }

        if ($userServiceRegisterPasskeyRequest === null || (is_array($userServiceRegisterPasskeyRequest) && count($userServiceRegisterPasskeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRegisterPasskeyRequest when calling userServiceRegisterPasskey'
            );
        }


        $resourcePath = '/v2/users/{userId}/passkeys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRegisterPasskeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRegisterPasskeyRequest));
            } else {
                $httpBody = $userServiceRegisterPasskeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRegisterTOTP
     *
     * Start the registration of a TOTP generator for a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterTOTPResponse
     * @throws ApiException
     */
    public function userServiceRegisterTOTP($userId, string $contentType = self::contentTypes['userServiceRegisterTOTP'][0])
    {
        $request = $this->userServiceRegisterTOTPRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterTOTPResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRegisterTOTP'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRegisterTOTPRequest($userId, string $contentType = self::contentTypes['userServiceRegisterTOTP'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRegisterTOTP'
            );
        }


        $resourcePath = '/v2/users/{userId}/totp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRegisterU2F
     *
     * Start the registration of a u2f token for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceRegisterU2FRequest $userServiceRegisterU2FRequest userServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterU2F'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterU2FResponse
     * @throws ApiException
     */
    public function userServiceRegisterU2F($userId, $userServiceRegisterU2FRequest, string $contentType = self::contentTypes['userServiceRegisterU2F'][0])
    {
        $request = $this->userServiceRegisterU2FRequest($userId, $userServiceRegisterU2FRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterU2FResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterU2FResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRegisterU2F'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceRegisterU2FRequest $userServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRegisterU2F'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRegisterU2FRequest($userId, $userServiceRegisterU2FRequest, string $contentType = self::contentTypes['userServiceRegisterU2F'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRegisterU2F'
            );
        }

        if ($userServiceRegisterU2FRequest === null || (is_array($userServiceRegisterU2FRequest) && count($userServiceRegisterU2FRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRegisterU2FRequest when calling userServiceRegisterU2F'
            );
        }


        $resourcePath = '/v2/users/{userId}/u2f';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRegisterU2FRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRegisterU2FRequest));
            } else {
                $httpBody = $userServiceRegisterU2FRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemoveIDPLink
     *
     * Remove link of an identity provider to an user
     *
     * @param  string $userId userId (required)
     * @param  string $idpId idpId (required)
     * @param  string $linkedUserId linkedUserId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveIDPLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse
     * @throws ApiException
     */
    public function userServiceRemoveIDPLink($userId, $idpId, $linkedUserId, string $contentType = self::contentTypes['userServiceRemoveIDPLink'][0])
    {
        $request = $this->userServiceRemoveIDPLinkRequest($userId, $idpId, $linkedUserId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemoveIDPLink'
     *
     * @param  string $userId (required)
     * @param  string $idpId (required)
     * @param  string $linkedUserId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveIDPLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemoveIDPLinkRequest($userId, $idpId, $linkedUserId, string $contentType = self::contentTypes['userServiceRemoveIDPLink'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemoveIDPLink'
            );
        }

        if ($idpId === null || (is_array($idpId) && count($idpId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $idpId when calling userServiceRemoveIDPLink'
            );
        }

        if ($linkedUserId === null || (is_array($linkedUserId) && count($linkedUserId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkedUserId when calling userServiceRemoveIDPLink'
            );
        }


        $resourcePath = '/v2/users/{userId}/links/{idpId}/{linkedUserId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        if ($idpId !== null) {
            $resourcePath = str_replace(
                '{' . 'idpId' . '}',
                ObjectSerializer::toPathValue($idpId),
                $resourcePath
            );
        }
        if ($linkedUserId !== null) {
            $resourcePath = str_replace(
                '{' . 'linkedUserId' . '}',
                ObjectSerializer::toPathValue($linkedUserId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemoveOTPEmail
     *
     * Remove One-Time Password (OTP) Email from a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse
     * @throws ApiException
     */
    public function userServiceRemoveOTPEmail($userId, string $contentType = self::contentTypes['userServiceRemoveOTPEmail'][0])
    {
        $request = $this->userServiceRemoveOTPEmailRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemoveOTPEmail'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemoveOTPEmailRequest($userId, string $contentType = self::contentTypes['userServiceRemoveOTPEmail'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemoveOTPEmail'
            );
        }


        $resourcePath = '/v2/users/{userId}/otp_email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemoveOTPSMS
     *
     * Remove One-Time Password (OTP) SMS from a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse
     * @throws ApiException
     */
    public function userServiceRemoveOTPSMS($userId, string $contentType = self::contentTypes['userServiceRemoveOTPSMS'][0])
    {
        $request = $this->userServiceRemoveOTPSMSRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemoveOTPSMS'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemoveOTPSMSRequest($userId, string $contentType = self::contentTypes['userServiceRemoveOTPSMS'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemoveOTPSMS'
            );
        }


        $resourcePath = '/v2/users/{userId}/otp_sms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemovePasskey
     *
     * Remove passkey from a user
     *
     * @param  string $userId userId (required)
     * @param  string $passkeyId passkeyId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemovePasskey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemovePasskeyResponse
     * @throws ApiException
     */
    public function userServiceRemovePasskey($userId, $passkeyId, string $contentType = self::contentTypes['userServiceRemovePasskey'][0])
    {
        $request = $this->userServiceRemovePasskeyRequest($userId, $passkeyId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemovePasskeyResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemovePasskeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemovePasskey'
     *
     * @param  string $userId (required)
     * @param  string $passkeyId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemovePasskey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemovePasskeyRequest($userId, $passkeyId, string $contentType = self::contentTypes['userServiceRemovePasskey'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemovePasskey'
            );
        }

        if ($passkeyId === null || (is_array($passkeyId) && count($passkeyId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $passkeyId when calling userServiceRemovePasskey'
            );
        }


        $resourcePath = '/v2/users/{userId}/passkeys/{passkeyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        if ($passkeyId !== null) {
            $resourcePath = str_replace(
                '{' . 'passkeyId' . '}',
                ObjectSerializer::toPathValue($passkeyId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemovePhone
     *
     * Delete the user phone
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemovePhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemovePhoneResponse
     * @throws ApiException
     */
    public function userServiceRemovePhone($userId, string $contentType = self::contentTypes['userServiceRemovePhone'][0])
    {
        $request = $this->userServiceRemovePhoneRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemovePhoneResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemovePhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemovePhone'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemovePhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemovePhoneRequest($userId, string $contentType = self::contentTypes['userServiceRemovePhone'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemovePhone'
            );
        }


        $resourcePath = '/v2/users/{userId}/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemoveTOTP
     *
     * Remove TOTP generator from a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveTOTPResponse
     * @throws ApiException
     */
    public function userServiceRemoveTOTP($userId, string $contentType = self::contentTypes['userServiceRemoveTOTP'][0])
    {
        $request = $this->userServiceRemoveTOTPRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveTOTPResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemoveTOTP'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemoveTOTPRequest($userId, string $contentType = self::contentTypes['userServiceRemoveTOTP'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemoveTOTP'
            );
        }


        $resourcePath = '/v2/users/{userId}/totp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRemoveU2F
     *
     * Remove u2f token from a user
     *
     * @param  string $userId userId (required)
     * @param  string $u2fId u2fId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveU2F'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveU2FResponse
     * @throws ApiException
     */
    public function userServiceRemoveU2F($userId, $u2fId, string $contentType = self::contentTypes['userServiceRemoveU2F'][0])
    {
        $request = $this->userServiceRemoveU2FRequest($userId, $u2fId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveU2FResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveU2FResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRemoveU2F'
     *
     * @param  string $userId (required)
     * @param  string $u2fId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRemoveU2F'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRemoveU2FRequest($userId, $u2fId, string $contentType = self::contentTypes['userServiceRemoveU2F'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceRemoveU2F'
            );
        }

        if ($u2fId === null || (is_array($u2fId) && count($u2fId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $u2fId when calling userServiceRemoveU2F'
            );
        }


        $resourcePath = '/v2/users/{userId}/u2f/{u2fId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        if ($u2fId !== null) {
            $resourcePath = str_replace(
                '{' . 'u2fId' . '}',
                ObjectSerializer::toPathValue($u2fId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceResendEmailCode
     *
     * Resend code to verify user email
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceResendEmailCodeRequest $userServiceResendEmailCodeRequest userServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendEmailCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendEmailCodeResponse
     * @throws ApiException
     */
    public function userServiceResendEmailCode($userId, $userServiceResendEmailCodeRequest, string $contentType = self::contentTypes['userServiceResendEmailCode'][0])
    {
        $request = $this->userServiceResendEmailCodeRequest($userId, $userServiceResendEmailCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendEmailCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendEmailCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceResendEmailCode'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceResendEmailCodeRequest $userServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendEmailCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceResendEmailCodeRequest($userId, $userServiceResendEmailCodeRequest, string $contentType = self::contentTypes['userServiceResendEmailCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceResendEmailCode'
            );
        }

        if ($userServiceResendEmailCodeRequest === null || (is_array($userServiceResendEmailCodeRequest) && count($userServiceResendEmailCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceResendEmailCodeRequest when calling userServiceResendEmailCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/email/resend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceResendEmailCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceResendEmailCodeRequest));
            } else {
                $httpBody = $userServiceResendEmailCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceResendInviteCode
     *
     * Resend an invite code for a user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendInviteCodeResponse
     * @throws ApiException
     */
    public function userServiceResendInviteCode($userId, string $contentType = self::contentTypes['userServiceResendInviteCode'][0])
    {
        $request = $this->userServiceResendInviteCodeRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendInviteCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceResendInviteCode'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceResendInviteCodeRequest($userId, string $contentType = self::contentTypes['userServiceResendInviteCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceResendInviteCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/invite_code/resend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceResendPhoneCode
     *
     * Resend code to verify user phone
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceResendPhoneCodeRequest $userServiceResendPhoneCodeRequest userServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendPhoneCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendPhoneCodeResponse
     * @throws ApiException
     */
    public function userServiceResendPhoneCode($userId, $userServiceResendPhoneCodeRequest, string $contentType = self::contentTypes['userServiceResendPhoneCode'][0])
    {
        $request = $this->userServiceResendPhoneCodeRequest($userId, $userServiceResendPhoneCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendPhoneCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendPhoneCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceResendPhoneCode'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceResendPhoneCodeRequest $userServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceResendPhoneCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceResendPhoneCodeRequest($userId, $userServiceResendPhoneCodeRequest, string $contentType = self::contentTypes['userServiceResendPhoneCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceResendPhoneCode'
            );
        }

        if ($userServiceResendPhoneCodeRequest === null || (is_array($userServiceResendPhoneCodeRequest) && count($userServiceResendPhoneCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceResendPhoneCodeRequest when calling userServiceResendPhoneCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/phone/resend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceResendPhoneCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceResendPhoneCodeRequest));
            } else {
                $httpBody = $userServiceResendPhoneCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceRetrieveIdentityProviderIntent
     *
     * Retrieve the information returned by the identity provider
     *
     * @param  string $idpIntentId ID of the idp intent, previously returned on the success response of the IDP callback (required)
     * @param  \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentRequest $userServiceRetrieveIdentityProviderIntentRequest userServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRetrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function userServiceRetrieveIdentityProviderIntent($idpIntentId, $userServiceRetrieveIdentityProviderIntentRequest, string $contentType = self::contentTypes['userServiceRetrieveIdentityProviderIntent'][0])
    {
        $request = $this->userServiceRetrieveIdentityProviderIntentRequest($idpIntentId, $userServiceRetrieveIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceRetrieveIdentityProviderIntent'
     *
     * @param  string $idpIntentId ID of the idp intent, previously returned on the success response of the IDP callback (required)
     * @param  \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentRequest $userServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceRetrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceRetrieveIdentityProviderIntentRequest($idpIntentId, $userServiceRetrieveIdentityProviderIntentRequest, string $contentType = self::contentTypes['userServiceRetrieveIdentityProviderIntent'][0])
    {

        if ($idpIntentId === null || (is_array($idpIntentId) && count($idpIntentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $idpIntentId when calling userServiceRetrieveIdentityProviderIntent'
            );
        }

        if ($userServiceRetrieveIdentityProviderIntentRequest === null || (is_array($userServiceRetrieveIdentityProviderIntentRequest) && count($userServiceRetrieveIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRetrieveIdentityProviderIntentRequest when calling userServiceRetrieveIdentityProviderIntent'
            );
        }


        $resourcePath = '/v2/idp_intents/{idpIntentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($idpIntentId !== null) {
            $resourcePath = str_replace(
                '{' . 'idpIntentId' . '}',
                ObjectSerializer::toPathValue($idpIntentId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRetrieveIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRetrieveIdentityProviderIntentRequest));
            } else {
                $httpBody = $userServiceRetrieveIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceSendEmailCode
     *
     * Send code to verify user email
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSendEmailCodeRequest $userServiceSendEmailCodeRequest userServiceSendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSendEmailCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSendEmailCodeResponse
     * @throws ApiException
     */
    public function userServiceSendEmailCode($userId, $userServiceSendEmailCodeRequest, string $contentType = self::contentTypes['userServiceSendEmailCode'][0])
    {
        $request = $this->userServiceSendEmailCodeRequest($userId, $userServiceSendEmailCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSendEmailCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSendEmailCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceSendEmailCode'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSendEmailCodeRequest $userServiceSendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSendEmailCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceSendEmailCodeRequest($userId, $userServiceSendEmailCodeRequest, string $contentType = self::contentTypes['userServiceSendEmailCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceSendEmailCode'
            );
        }

        if ($userServiceSendEmailCodeRequest === null || (is_array($userServiceSendEmailCodeRequest) && count($userServiceSendEmailCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSendEmailCodeRequest when calling userServiceSendEmailCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/email/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSendEmailCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSendEmailCodeRequest));
            } else {
                $httpBody = $userServiceSendEmailCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceSetEmail
     *
     * Change the user email
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetEmailRequest $userServiceSetEmailRequest userServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetEmailResponse
     * @throws ApiException
     */
    public function userServiceSetEmail($userId, $userServiceSetEmailRequest, string $contentType = self::contentTypes['userServiceSetEmail'][0])
    {
        $request = $this->userServiceSetEmailRequest($userId, $userServiceSetEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetEmailResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceSetEmail'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetEmailRequest $userServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceSetEmailRequest($userId, $userServiceSetEmailRequest, string $contentType = self::contentTypes['userServiceSetEmail'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceSetEmail'
            );
        }

        if ($userServiceSetEmailRequest === null || (is_array($userServiceSetEmailRequest) && count($userServiceSetEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetEmailRequest when calling userServiceSetEmail'
            );
        }


        $resourcePath = '/v2/users/{userId}/email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetEmailRequest));
            } else {
                $httpBody = $userServiceSetEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceSetPassword
     *
     * Change password
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetPasswordRequest $userServiceSetPasswordRequest userServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetPassword'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetPasswordResponse
     * @throws ApiException
     */
    public function userServiceSetPassword($userId, $userServiceSetPasswordRequest, string $contentType = self::contentTypes['userServiceSetPassword'][0])
    {
        $request = $this->userServiceSetPasswordRequest($userId, $userServiceSetPasswordRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetPasswordResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetPasswordResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceSetPassword'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetPasswordRequest $userServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceSetPasswordRequest($userId, $userServiceSetPasswordRequest, string $contentType = self::contentTypes['userServiceSetPassword'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceSetPassword'
            );
        }

        if ($userServiceSetPasswordRequest === null || (is_array($userServiceSetPasswordRequest) && count($userServiceSetPasswordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetPasswordRequest when calling userServiceSetPassword'
            );
        }


        $resourcePath = '/v2/users/{userId}/password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetPasswordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetPasswordRequest));
            } else {
                $httpBody = $userServiceSetPasswordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceSetPhone
     *
     * Set the user phone
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetPhoneRequest $userServiceSetPhoneRequest userServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetPhoneResponse
     * @throws ApiException
     */
    public function userServiceSetPhone($userId, $userServiceSetPhoneRequest, string $contentType = self::contentTypes['userServiceSetPhone'][0])
    {
        $request = $this->userServiceSetPhoneRequest($userId, $userServiceSetPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetPhoneResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceSetPhone'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceSetPhoneRequest $userServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceSetPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceSetPhoneRequest($userId, $userServiceSetPhoneRequest, string $contentType = self::contentTypes['userServiceSetPhone'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceSetPhone'
            );
        }

        if ($userServiceSetPhoneRequest === null || (is_array($userServiceSetPhoneRequest) && count($userServiceSetPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetPhoneRequest when calling userServiceSetPhone'
            );
        }


        $resourcePath = '/v2/users/{userId}/phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetPhoneRequest));
            } else {
                $httpBody = $userServiceSetPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceStartIdentityProviderIntent
     *
     * Start flow with an identity provider
     *
     * @param  \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentRequest $userServiceStartIdentityProviderIntentRequest userServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceStartIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function userServiceStartIdentityProviderIntent($userServiceStartIdentityProviderIntentRequest, string $contentType = self::contentTypes['userServiceStartIdentityProviderIntent'][0])
    {
        $request = $this->userServiceStartIdentityProviderIntentRequest($userServiceStartIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceStartIdentityProviderIntent'
     *
     * @param  \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentRequest $userServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceStartIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceStartIdentityProviderIntentRequest($userServiceStartIdentityProviderIntentRequest, string $contentType = self::contentTypes['userServiceStartIdentityProviderIntent'][0])
    {

        if ($userServiceStartIdentityProviderIntentRequest === null || (is_array($userServiceStartIdentityProviderIntentRequest) && count($userServiceStartIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceStartIdentityProviderIntentRequest when calling userServiceStartIdentityProviderIntent'
            );
        }


        $resourcePath = '/v2/idp_intents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceStartIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceStartIdentityProviderIntentRequest));
            } else {
                $httpBody = $userServiceStartIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceUnlockUser
     *
     * Unlock user
     *
     * @param  string $userId userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceUnlockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceUnlockUserResponse
     * @throws ApiException
     */
    public function userServiceUnlockUser($userId, string $contentType = self::contentTypes['userServiceUnlockUser'][0])
    {
        $request = $this->userServiceUnlockUserRequest($userId, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceUnlockUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceUnlockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceUnlockUser'
     *
     * @param  string $userId (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceUnlockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceUnlockUserRequest($userId, string $contentType = self::contentTypes['userServiceUnlockUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceUnlockUser'
            );
        }


        $resourcePath = '/v2/users/{userId}/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceUpdateHumanUser
     *
     * Update User
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceUpdateHumanUserRequest $userServiceUpdateHumanUserRequest userServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceUpdateHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceUpdateHumanUserResponse
     * @throws ApiException
     */
    public function userServiceUpdateHumanUser($userId, $userServiceUpdateHumanUserRequest, string $contentType = self::contentTypes['userServiceUpdateHumanUser'][0])
    {
        $request = $this->userServiceUpdateHumanUserRequest($userId, $userServiceUpdateHumanUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceUpdateHumanUserResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceUpdateHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceUpdateHumanUser'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceUpdateHumanUserRequest $userServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceUpdateHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceUpdateHumanUserRequest($userId, $userServiceUpdateHumanUserRequest, string $contentType = self::contentTypes['userServiceUpdateHumanUser'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceUpdateHumanUser'
            );
        }

        if ($userServiceUpdateHumanUserRequest === null || (is_array($userServiceUpdateHumanUserRequest) && count($userServiceUpdateHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceUpdateHumanUserRequest when calling userServiceUpdateHumanUser'
            );
        }


        $resourcePath = '/v2/users/human/{userId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceUpdateHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceUpdateHumanUserRequest));
            } else {
                $httpBody = $userServiceUpdateHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyEmail
     *
     * Verify the email
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyEmailRequest $userServiceVerifyEmailRequest userServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyEmailResponse
     * @throws ApiException
     */
    public function userServiceVerifyEmail($userId, $userServiceVerifyEmailRequest, string $contentType = self::contentTypes['userServiceVerifyEmail'][0])
    {
        $request = $this->userServiceVerifyEmailRequest($userId, $userServiceVerifyEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyEmailResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyEmail'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyEmailRequest $userServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyEmailRequest($userId, $userServiceVerifyEmailRequest, string $contentType = self::contentTypes['userServiceVerifyEmail'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyEmail'
            );
        }

        if ($userServiceVerifyEmailRequest === null || (is_array($userServiceVerifyEmailRequest) && count($userServiceVerifyEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyEmailRequest when calling userServiceVerifyEmail'
            );
        }


        $resourcePath = '/v2/users/{userId}/email/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyEmailRequest));
            } else {
                $httpBody = $userServiceVerifyEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyInviteCode
     *
     * Verify an invite code for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyInviteCodeRequest $userServiceVerifyInviteCodeRequest userServiceVerifyInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse
     * @throws ApiException
     */
    public function userServiceVerifyInviteCode($userId, $userServiceVerifyInviteCodeRequest, string $contentType = self::contentTypes['userServiceVerifyInviteCode'][0])
    {
        $request = $this->userServiceVerifyInviteCodeRequest($userId, $userServiceVerifyInviteCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyInviteCode'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyInviteCodeRequest $userServiceVerifyInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyInviteCodeRequest($userId, $userServiceVerifyInviteCodeRequest, string $contentType = self::contentTypes['userServiceVerifyInviteCode'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyInviteCode'
            );
        }

        if ($userServiceVerifyInviteCodeRequest === null || (is_array($userServiceVerifyInviteCodeRequest) && count($userServiceVerifyInviteCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyInviteCodeRequest when calling userServiceVerifyInviteCode'
            );
        }


        $resourcePath = '/v2/users/{userId}/invite_code/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyInviteCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyInviteCodeRequest));
            } else {
                $httpBody = $userServiceVerifyInviteCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyPasskeyRegistration
     *
     * Verify a passkey for a user
     *
     * @param  string $userId userId (required)
     * @param  string $passkeyId passkeyId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationRequest $userServiceVerifyPasskeyRegistrationRequest userServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse
     * @throws ApiException
     */
    public function userServiceVerifyPasskeyRegistration($userId, $passkeyId, $userServiceVerifyPasskeyRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyPasskeyRegistration'][0])
    {
        $request = $this->userServiceVerifyPasskeyRegistrationRequest($userId, $passkeyId, $userServiceVerifyPasskeyRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyPasskeyRegistration'
     *
     * @param  string $userId (required)
     * @param  string $passkeyId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationRequest $userServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyPasskeyRegistrationRequest($userId, $passkeyId, $userServiceVerifyPasskeyRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyPasskeyRegistration'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyPasskeyRegistration'
            );
        }

        if ($passkeyId === null || (is_array($passkeyId) && count($passkeyId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $passkeyId when calling userServiceVerifyPasskeyRegistration'
            );
        }

        if ($userServiceVerifyPasskeyRegistrationRequest === null || (is_array($userServiceVerifyPasskeyRegistrationRequest) && count($userServiceVerifyPasskeyRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyPasskeyRegistrationRequest when calling userServiceVerifyPasskeyRegistration'
            );
        }


        $resourcePath = '/v2/users/{userId}/passkeys/{passkeyId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        if ($passkeyId !== null) {
            $resourcePath = str_replace(
                '{' . 'passkeyId' . '}',
                ObjectSerializer::toPathValue($passkeyId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyPasskeyRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyPasskeyRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyPasskeyRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyPhone
     *
     * Verify the phone
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyPhoneRequest $userServiceVerifyPhoneRequest userServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyPhoneResponse
     * @throws ApiException
     */
    public function userServiceVerifyPhone($userId, $userServiceVerifyPhoneRequest, string $contentType = self::contentTypes['userServiceVerifyPhone'][0])
    {
        $request = $this->userServiceVerifyPhoneRequest($userId, $userServiceVerifyPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyPhoneResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyPhone'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyPhoneRequest $userServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyPhoneRequest($userId, $userServiceVerifyPhoneRequest, string $contentType = self::contentTypes['userServiceVerifyPhone'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyPhone'
            );
        }

        if ($userServiceVerifyPhoneRequest === null || (is_array($userServiceVerifyPhoneRequest) && count($userServiceVerifyPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyPhoneRequest when calling userServiceVerifyPhone'
            );
        }


        $resourcePath = '/v2/users/{userId}/phone/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyPhoneRequest));
            } else {
                $httpBody = $userServiceVerifyPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyTOTPRegistration
     *
     * Verify a TOTP generator for a user
     *
     * @param  string $userId userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationRequest $userServiceVerifyTOTPRegistrationRequest userServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyTOTPRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse
     * @throws ApiException
     */
    public function userServiceVerifyTOTPRegistration($userId, $userServiceVerifyTOTPRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyTOTPRegistration'][0])
    {
        $request = $this->userServiceVerifyTOTPRegistrationRequest($userId, $userServiceVerifyTOTPRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyTOTPRegistration'
     *
     * @param  string $userId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationRequest $userServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyTOTPRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyTOTPRegistrationRequest($userId, $userServiceVerifyTOTPRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyTOTPRegistration'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyTOTPRegistration'
            );
        }

        if ($userServiceVerifyTOTPRegistrationRequest === null || (is_array($userServiceVerifyTOTPRegistrationRequest) && count($userServiceVerifyTOTPRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyTOTPRegistrationRequest when calling userServiceVerifyTOTPRegistration'
            );
        }


        $resourcePath = '/v2/users/{userId}/totp/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyTOTPRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyTOTPRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyTOTPRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation userServiceVerifyU2FRegistration
     *
     * Verify a u2f token for a user
     *
     * @param  string $userId userId (required)
     * @param  string $u2fId u2fId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationRequest $userServiceVerifyU2FRegistrationRequest userServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyU2FRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse
     * @throws ApiException
     */
    public function userServiceVerifyU2FRegistration($userId, $u2fId, $userServiceVerifyU2FRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyU2FRegistration'][0])
    {
        $request = $this->userServiceVerifyU2FRegistrationRequest($userId, $u2fId, $userServiceVerifyU2FRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse',
            403 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            404 => '\Zitadel\Client\Model\UserServiceRpcStatus',
            'default' => '\Zitadel\Client\Model\UserServiceRpcStatus',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'userServiceVerifyU2FRegistration'
     *
     * @param  string $userId (required)
     * @param  string $u2fId (required)
     * @param  \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationRequest $userServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userServiceVerifyU2FRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function userServiceVerifyU2FRegistrationRequest($userId, $u2fId, $userServiceVerifyU2FRegistrationRequest, string $contentType = self::contentTypes['userServiceVerifyU2FRegistration'][0])
    {

        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling userServiceVerifyU2FRegistration'
            );
        }

        if ($u2fId === null || (is_array($u2fId) && count($u2fId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $u2fId when calling userServiceVerifyU2FRegistration'
            );
        }

        if ($userServiceVerifyU2FRegistrationRequest === null || (is_array($userServiceVerifyU2FRegistrationRequest) && count($userServiceVerifyU2FRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyU2FRegistrationRequest when calling userServiceVerifyU2FRegistration'
            );
        }


        $resourcePath = '/v2/users/{userId}/u2f/{u2fId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'userId' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        if ($u2fId !== null) {
            $resourcePath = str_replace(
                '{' . 'u2fId' . '}',
                ObjectSerializer::toPathValue($u2fId),
                $resourcePath
            );
        }


        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyU2FRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyU2FRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyU2FRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
