<?php
/**
 * UserServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zitadel SDK
 *
 * The Zitadel SDK is a convenience wrapper around the Zitadel APIs to assist you in integrating with your Zitadel environment. This SDK enables you to handle resources, settings, and configurations within the Zitadel platform.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Zitadel\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Zitadel\Client\ApiException;
use Zitadel\Client\Configuration;
use Zitadel\Client\ObjectSerializer;
use RuntimeException;
use Exception;

/**
 * UserServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Zitadel\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addHumanUser' => [
            'application/json',
        ],
        'addIDPLink' => [
            'application/json',
        ],
        'addKey' => [
            'application/json',
        ],
        'addOTPEmail' => [
            'application/json',
        ],
        'addOTPSMS' => [
            'application/json',
        ],
        'addPersonalAccessToken' => [
            'application/json',
        ],
        'addSecret' => [
            'application/json',
        ],
        'createInviteCode' => [
            'application/json',
        ],
        'createPasskeyRegistrationLink' => [
            'application/json',
        ],
        'createUser' => [
            'application/json',
        ],
        'deactivateUser' => [
            'application/json',
        ],
        'deleteUser' => [
            'application/json',
        ],
        'deleteUserMetadata' => [
            'application/json',
        ],
        'getUserByID' => [
            'application/json',
        ],
        'humanMFAInitSkipped' => [
            'application/json',
        ],
        'listAuthenticationFactors' => [
            'application/json',
        ],
        'listAuthenticationMethodTypes' => [
            'application/json',
        ],
        'listIDPLinks' => [
            'application/json',
        ],
        'listKeys' => [
            'application/json',
        ],
        'listPasskeys' => [
            'application/json',
        ],
        'listPersonalAccessTokens' => [
            'application/json',
        ],
        'listUserMetadata' => [
            'application/json',
        ],
        'listUsers' => [
            'application/json',
        ],
        'lockUser' => [
            'application/json',
        ],
        'noOp' => [
            'application/json',
        ],
        'passwordReset' => [
            'application/json',
        ],
        'reactivateUser' => [
            'application/json',
        ],
        'registerPasskey' => [
            'application/json',
        ],
        'registerTOTP' => [
            'application/json',
        ],
        'registerU2F' => [
            'application/json',
        ],
        'removeIDPLink' => [
            'application/json',
        ],
        'removeKey' => [
            'application/json',
        ],
        'removeOTPEmail' => [
            'application/json',
        ],
        'removeOTPSMS' => [
            'application/json',
        ],
        'removePasskey' => [
            'application/json',
        ],
        'removePersonalAccessToken' => [
            'application/json',
        ],
        'removePhone' => [
            'application/json',
        ],
        'removeSecret' => [
            'application/json',
        ],
        'removeTOTP' => [
            'application/json',
        ],
        'removeU2F' => [
            'application/json',
        ],
        'resendEmailCode' => [
            'application/json',
        ],
        'resendInviteCode' => [
            'application/json',
        ],
        'resendPhoneCode' => [
            'application/json',
        ],
        'retrieveIdentityProviderIntent' => [
            'application/json',
        ],
        'sendEmailCode' => [
            'application/json',
        ],
        'setEmail' => [
            'application/json',
        ],
        'setPassword' => [
            'application/json',
        ],
        'setPhone' => [
            'application/json',
        ],
        'setUserMetadata' => [
            'application/json',
        ],
        'startIdentityProviderIntent' => [
            'application/json',
        ],
        'unlockUser' => [
            'application/json',
        ],
        'updateHumanUser' => [
            'application/json',
        ],
        'updateUser' => [
            'application/json',
        ],
        'verifyEmail' => [
            'application/json',
        ],
        'verifyInviteCode' => [
            'application/json',
        ],
        'verifyPasskeyRegistration' => [
            'application/json',
        ],
        'verifyPhone' => [
            'application/json',
        ],
        'verifyTOTPRegistration' => [
            'application/json',
        ],
        'verifyU2FRegistration' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        Configuration $config = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client([
            'http_errors' => false,
        ]);
        $this->config = $config;
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * @param string[] $accept
     * @param string $contentType
     * @param bool $isMultipart
     * @return string[]
     */
    private function selectHeaders(array $accept, string $contentType, bool $isMultipart): array
    {
        $headers = [];

        $accept = $this->selectAcceptHeader($accept);
        if ($accept !== null) {
            $headers['Accept'] = $accept;
        }

        if (!$isMultipart) {
            if ($contentType === '') {
                $contentType = 'application/json';
            }

            $headers['Content-Type'] = $contentType;
        }

        return $headers;
    }

    /**
     * Return the header 'Accept' based on an array of Accept provided.
     *
     * @param string[] $accept Array of header
     *
     * @return null|string Accept (e.g. application/json)
     */
    private function selectAcceptHeader(array $accept): ?string
    {
        # filter out empty entries
        $accept = array_filter($accept);

        if (count($accept) === 0) {
            return null;
        }

        # If there's only one Accept header, just use it
        if (count($accept) === 1) {
            return reset($accept);
        }

        # If none of the available Accept headers is of type "json", then just use all them
        $headersWithJson = $this->selectJsonMimeList($accept);
        if (count($headersWithJson) === 0) {
            return implode(',', $accept);
        }

        # If we got here, then we need add quality values (weight), as described in IETF RFC 9110, Items 12.4.2/12.5.1,
        # to give the highest priority to json-like headers - recalculating the existing ones, if needed
        return $this->getAcceptHeaderWithAdjustedWeight($accept, $headersWithJson);
    }

    /**
     * Select all items from a list containing a JSON mime type
     *
     * @param array $mimeList
     * @return array
     */
    private function selectJsonMimeList(array $mimeList): array
    {
        $jsonMimeList = [];
        foreach ($mimeList as $mime) {
            if ($this->isJsonMime($mime)) {
                $jsonMimeList[] = $mime;
            }
        }
        return $jsonMimeList;
    }

    /**
     * Detects whether a string contains a valid JSON mime type
     *
     * @param string $searchString
     * @return bool
     */
    private function isJsonMime(string $searchString): bool
    {
        /** @noinspection PhpCoveredCharacterInClassInspection */
        return preg_match('~^application/(json|[\w!#$&.+-^_]+\+json)\s*(;|$)~', $searchString) === 1;
    }

    /**
     * Create an Accept header string from the given "Accept" headers array, recalculating all weights
     *
     * @param string[] $accept Array of Accept Headers
     * @param string[] $headersWithJson Array of Accept Headers of type "json"
     *
     * @return string "Accept" Header (e.g. "application/json, text/html; q=0.9")
     */
    private function getAcceptHeaderWithAdjustedWeight(array $accept, array $headersWithJson): string
    {
        $processedHeaders = [
          'withApplicationJson' => [],
          'withJson' => [],
          'withoutJson' => [],
        ];

        foreach ($accept as $header) {

            $headerData = $this->getHeaderAndWeight($header);

            if (stripos($headerData['header'], 'application/json') === 0) {
                $processedHeaders['withApplicationJson'][] = $headerData;
            } elseif (in_array($header, $headersWithJson, true)) {
                $processedHeaders['withJson'][] = $headerData;
            } else {
                $processedHeaders['withoutJson'][] = $headerData;
            }
        }

        $acceptHeaders = [];
        $currentWeight = 1000;

        $hasMoreThan28Headers = count($accept) > 28;

        foreach ($processedHeaders as $headers) {
            if (count($headers) > 0) {
                $acceptHeaders[] = $this->adjustWeight($headers, $currentWeight, $hasMoreThan28Headers);
            }
        }

        $acceptHeaders = array_merge(...$acceptHeaders);

        return implode(',', $acceptHeaders);
    }

    /**
     * Given an Accept header, returns an associative array splitting the header and its weight
     *
     * @param string $header "Accept" Header
     *
     * @return array with the header and its weight
     */
    private function getHeaderAndWeight(string $header): array
    {
        # matches headers with weight, splitting the header and the weight in $outputArray
        if (preg_match('/(.*);\s*q=(1(?:\.0+)?|0\.\d+)$/', $header, $outputArray) === 1) {
            $headerData = [
              'header' => $outputArray[1],
              'weight' => (int)($outputArray[2] * 1000),
            ];
        } else {
            $headerData = [
              'header' => trim($header),
              'weight' => 1000,
            ];
        }

        return $headerData;
    }

    /**
     * @param array[] $headers
     * @param float $currentWeight
     * @param bool $hasMoreThan28Headers
     * @return string[] array of adjusted "Accept" headers
     */
    private function adjustWeight(array $headers, float &$currentWeight, bool $hasMoreThan28Headers): array
    {
        usort($headers, fn (array $a, array $b) => $b['weight'] - $a['weight']);

        $acceptHeaders = [];
        foreach ($headers as $index => $header) {
            if ($index > 0 && $headers[$index - 1]['weight'] > $header['weight']) {
                $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);
            }

            $weight = $currentWeight;

            $acceptHeaders[] = $this->buildAcceptHeader($header['header'], $weight);
        }

        $currentWeight = $this->getNextWeight($currentWeight, $hasMoreThan28Headers);

        return $acceptHeaders;
    }

    /**
     * Calculate the next weight, based on the current one.
     *
     * If there are less than 28 "Accept" headers, the weights will be decreased by 1 on its highest significant digit, using the
     * following formula:
     *
     *    next weight = current weight - 10 ^ (floor(log(current weight - 1)))
     *
     *    ( current weight minus ( 10 raised to the power of ( floor of (log to the base 10 of ( current weight minus 1 ) ) ) ) )
     *
     * Starting from 1000, this generates the following series:
     *
     * 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
     *
     * The resulting quality codes are closer to the average "normal" usage of them (like "q=0.9", "q=0.8" and so on), but it only works
     * if there is a maximum of 28 "Accept" headers. If we have more than that (which is extremely unlikely), then we fall back to a 1-by-1
     * decrement rule, which will result in quality codes like "q=0.999", "q=0.998" etc.
     *
     * @param int $currentWeight varying from 1 to 1000 (will be divided by 1000 to build the quality value)
     * @param bool $hasMoreThan28Headers
     * @return int
     */
    private function getNextWeight(int $currentWeight, bool $hasMoreThan28Headers): int
    {
        if ($currentWeight <= 1) {
            return 1;
        }

        if ($hasMoreThan28Headers) {
            return $currentWeight - 1;
        }

        return $currentWeight - 10 ** floor(log10($currentWeight - 1));
    }

    /**
     * @param string $header
     * @param int $weight
     * @return string
     */
    private function buildAcceptHeader(string $header, int $weight): string
    {
        if ($weight === 1000) {
            return $header;
        }

        return trim($header, '; ') . ';q=' . rtrim(sprintf('%0.3f', $weight / 1000), '0');
    }


        /**
     * @throws ApiException
     */
    private function executeRequest(
        Request $request,
        array $responseTypes,
        string $defaultResponseType
    ): mixed {
        try {
            $options = $this->createHttpClientOption();
            $response = $this->client->send($request, $options);
        } catch (GuzzleException $e) {
            throw new RuntimeException(
                "API Request failed: [{$e->getCode()}] {$e->getMessage()}",
                (int) $e->getCode(),
                $e
            );
        }

        $statusCode = $response->getStatusCode();
        $responseBody = $response->getBody();
        $responseHeaders = $response->getHeaders();

        if ($statusCode >= 200 && $statusCode < 300) {
            $returnType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($returnType === '\SplFileObject') {
                return $responseBody;
            } else {
                $content = (string) $responseBody;

                if (empty(trim($content)) && $returnType !== 'string') {
                    $content = null;
                }

                try {
                    return ObjectSerializer::deserialize($content, $returnType, $this->config, []);
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process successful response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            }
        } else {
            $errorType = $responseTypes[$statusCode] ?? $defaultResponseType;

            if ($errorType === '\SplFileObject') {
                throw new ApiException(
                    sprintf('[%d] API Error (%s) - Expected file object', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            } elseif ($errorType !== 'string' && !empty(trim((string) $responseBody))) {
                try {
                    $decodedContent = json_decode((string)$responseBody, false, 512, JSON_THROW_ON_ERROR);
                    throw new ApiException(
                        sprintf('[%d] API Error (%s)', $statusCode, (string)$request->getUri()),
                        $statusCode,
                        $responseHeaders,
                        $decodedContent,
                    );
                } catch (ApiException $e) {
                    throw $e;
                } catch (Exception $e) {
                    throw new RuntimeException(
                        "Failed to process error response for status $statusCode",
                        $statusCode,
                        $e
                    );
                }
            } else {
                throw new ApiException(
                    sprintf('[%d] API Error (%s)', $statusCode, $request->getUri()),
                    $statusCode,
                    $responseHeaders,
                    $responseBody
                );
            }
        }
    }

    /**
     * Operation addHumanUser
     *
     * AddHumanUser
     *
     * @param  \Zitadel\Client\Model\UserServiceAddHumanUserRequest $userServiceAddHumanUserRequest userServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddHumanUserResponse
     * @throws ApiException
     */
    public function addHumanUser(    $userServiceAddHumanUserRequest,string $contentType = self::contentTypes['addHumanUser'][0])
    {
        $request = $this->addHumanUserRequest($userServiceAddHumanUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddHumanUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addHumanUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddHumanUserRequest $userServiceAddHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addHumanUserRequest($userServiceAddHumanUserRequest, string $contentType = self::contentTypes['addHumanUser'][0])
    {

        if ($userServiceAddHumanUserRequest === null || (is_array($userServiceAddHumanUserRequest) && count($userServiceAddHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddHumanUserRequest when calling addHumanUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddHumanUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddHumanUserRequest));
            } else {
                $httpBody = $userServiceAddHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addIDPLink
     *
     * AddIDPLink
     *
     * @param  \Zitadel\Client\Model\UserServiceAddIDPLinkRequest $userServiceAddIDPLinkRequest userServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIDPLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddIDPLinkResponse
     * @throws ApiException
     */
    public function addIDPLink(    $userServiceAddIDPLinkRequest,string $contentType = self::contentTypes['addIDPLink'][0])
    {
        $request = $this->addIDPLinkRequest($userServiceAddIDPLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddIDPLinkResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddIDPLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addIDPLink'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddIDPLinkRequest $userServiceAddIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIDPLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addIDPLinkRequest($userServiceAddIDPLinkRequest, string $contentType = self::contentTypes['addIDPLink'][0])
    {

        if ($userServiceAddIDPLinkRequest === null || (is_array($userServiceAddIDPLinkRequest) && count($userServiceAddIDPLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddIDPLinkRequest when calling addIDPLink'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddIDPLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddIDPLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddIDPLinkRequest));
            } else {
                $httpBody = $userServiceAddIDPLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addKey
     *
     * AddKey
     *
     * @param  \Zitadel\Client\Model\UserServiceAddKeyRequest $userServiceAddKeyRequest userServiceAddKeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addKey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddKeyResponse
     * @throws ApiException
     */
    public function addKey(    $userServiceAddKeyRequest,string $contentType = self::contentTypes['addKey'][0])
    {
        $request = $this->addKeyRequest($userServiceAddKeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddKeyResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddKeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addKey'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddKeyRequest $userServiceAddKeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addKeyRequest($userServiceAddKeyRequest, string $contentType = self::contentTypes['addKey'][0])
    {

        if ($userServiceAddKeyRequest === null || (is_array($userServiceAddKeyRequest) && count($userServiceAddKeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddKeyRequest when calling addKey'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddKeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddKeyRequest));
            } else {
                $httpBody = $userServiceAddKeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addOTPEmail
     *
     * AddOTPEmail
     *
     * @param  \Zitadel\Client\Model\UserServiceAddOTPEmailRequest $userServiceAddOTPEmailRequest userServiceAddOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddOTPEmailResponse
     * @throws ApiException
     */
    public function addOTPEmail(    $userServiceAddOTPEmailRequest,string $contentType = self::contentTypes['addOTPEmail'][0])
    {
        $request = $this->addOTPEmailRequest($userServiceAddOTPEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddOTPEmailResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addOTPEmail'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddOTPEmailRequest $userServiceAddOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addOTPEmailRequest($userServiceAddOTPEmailRequest, string $contentType = self::contentTypes['addOTPEmail'][0])
    {

        if ($userServiceAddOTPEmailRequest === null || (is_array($userServiceAddOTPEmailRequest) && count($userServiceAddOTPEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddOTPEmailRequest when calling addOTPEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddOTPEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddOTPEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddOTPEmailRequest));
            } else {
                $httpBody = $userServiceAddOTPEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addOTPSMS
     *
     * AddOTPSMS
     *
     * @param  \Zitadel\Client\Model\UserServiceAddOTPSMSRequest $userServiceAddOTPSMSRequest userServiceAddOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddOTPSMSResponse
     * @throws ApiException
     */
    public function addOTPSMS(    $userServiceAddOTPSMSRequest,string $contentType = self::contentTypes['addOTPSMS'][0])
    {
        $request = $this->addOTPSMSRequest($userServiceAddOTPSMSRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddOTPSMSResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addOTPSMS'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddOTPSMSRequest $userServiceAddOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addOTPSMSRequest($userServiceAddOTPSMSRequest, string $contentType = self::contentTypes['addOTPSMS'][0])
    {

        if ($userServiceAddOTPSMSRequest === null || (is_array($userServiceAddOTPSMSRequest) && count($userServiceAddOTPSMSRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddOTPSMSRequest when calling addOTPSMS'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddOTPSMS';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddOTPSMSRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddOTPSMSRequest));
            } else {
                $httpBody = $userServiceAddOTPSMSRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addPersonalAccessToken
     *
     * AddPersonalAccessToken
     *
     * @param  \Zitadel\Client\Model\UserServiceAddPersonalAccessTokenRequest $userServiceAddPersonalAccessTokenRequest userServiceAddPersonalAccessTokenRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPersonalAccessToken'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddPersonalAccessTokenResponse
     * @throws ApiException
     */
    public function addPersonalAccessToken(    $userServiceAddPersonalAccessTokenRequest,string $contentType = self::contentTypes['addPersonalAccessToken'][0])
    {
        $request = $this->addPersonalAccessTokenRequest($userServiceAddPersonalAccessTokenRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddPersonalAccessTokenResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddPersonalAccessTokenResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addPersonalAccessToken'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddPersonalAccessTokenRequest $userServiceAddPersonalAccessTokenRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addPersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addPersonalAccessTokenRequest($userServiceAddPersonalAccessTokenRequest, string $contentType = self::contentTypes['addPersonalAccessToken'][0])
    {

        if ($userServiceAddPersonalAccessTokenRequest === null || (is_array($userServiceAddPersonalAccessTokenRequest) && count($userServiceAddPersonalAccessTokenRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddPersonalAccessTokenRequest when calling addPersonalAccessToken'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddPersonalAccessToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddPersonalAccessTokenRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddPersonalAccessTokenRequest));
            } else {
                $httpBody = $userServiceAddPersonalAccessTokenRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addSecret
     *
     * AddSecret
     *
     * @param  \Zitadel\Client\Model\UserServiceAddSecretRequest $userServiceAddSecretRequest userServiceAddSecretRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addSecret'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceAddSecretResponse
     * @throws ApiException
     */
    public function addSecret(    $userServiceAddSecretRequest,string $contentType = self::contentTypes['addSecret'][0])
    {
        $request = $this->addSecretRequest($userServiceAddSecretRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceAddSecretResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceAddSecretResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'addSecret'
     *
     * @param  \Zitadel\Client\Model\UserServiceAddSecretRequest $userServiceAddSecretRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function addSecretRequest($userServiceAddSecretRequest, string $contentType = self::contentTypes['addSecret'][0])
    {

        if ($userServiceAddSecretRequest === null || (is_array($userServiceAddSecretRequest) && count($userServiceAddSecretRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceAddSecretRequest when calling addSecret'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/AddSecret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceAddSecretRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceAddSecretRequest));
            } else {
                $httpBody = $userServiceAddSecretRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInviteCode
     *
     * CreateInviteCode
     *
     * @param  \Zitadel\Client\Model\UserServiceCreateInviteCodeRequest $userServiceCreateInviteCodeRequest userServiceCreateInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceCreateInviteCodeResponse
     * @throws ApiException
     */
    public function createInviteCode(    $userServiceCreateInviteCodeRequest,string $contentType = self::contentTypes['createInviteCode'][0])
    {
        $request = $this->createInviteCodeRequest($userServiceCreateInviteCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceCreateInviteCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceCreateInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'createInviteCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceCreateInviteCodeRequest $userServiceCreateInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function createInviteCodeRequest($userServiceCreateInviteCodeRequest, string $contentType = self::contentTypes['createInviteCode'][0])
    {

        if ($userServiceCreateInviteCodeRequest === null || (is_array($userServiceCreateInviteCodeRequest) && count($userServiceCreateInviteCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceCreateInviteCodeRequest when calling createInviteCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/CreateInviteCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceCreateInviteCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceCreateInviteCodeRequest));
            } else {
                $httpBody = $userServiceCreateInviteCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createPasskeyRegistrationLink
     *
     * CreatePasskeyRegistrationLink
     *
     * @param  \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkRequest $userServiceCreatePasskeyRegistrationLinkRequest userServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse
     * @throws ApiException
     */
    public function createPasskeyRegistrationLink(    $userServiceCreatePasskeyRegistrationLinkRequest,string $contentType = self::contentTypes['createPasskeyRegistrationLink'][0])
    {
        $request = $this->createPasskeyRegistrationLinkRequest($userServiceCreatePasskeyRegistrationLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'createPasskeyRegistrationLink'
     *
     * @param  \Zitadel\Client\Model\UserServiceCreatePasskeyRegistrationLinkRequest $userServiceCreatePasskeyRegistrationLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createPasskeyRegistrationLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function createPasskeyRegistrationLinkRequest($userServiceCreatePasskeyRegistrationLinkRequest, string $contentType = self::contentTypes['createPasskeyRegistrationLink'][0])
    {

        if ($userServiceCreatePasskeyRegistrationLinkRequest === null || (is_array($userServiceCreatePasskeyRegistrationLinkRequest) && count($userServiceCreatePasskeyRegistrationLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceCreatePasskeyRegistrationLinkRequest when calling createPasskeyRegistrationLink'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/CreatePasskeyRegistrationLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceCreatePasskeyRegistrationLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceCreatePasskeyRegistrationLinkRequest));
            } else {
                $httpBody = $userServiceCreatePasskeyRegistrationLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUser
     *
     * CreateUser
     *
     * @param  \Zitadel\Client\Model\UserServiceCreateUserRequest $userServiceCreateUserRequest userServiceCreateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceCreateUserResponse
     * @throws ApiException
     */
    public function createUser(    $userServiceCreateUserRequest,string $contentType = self::contentTypes['createUser'][0])
    {
        $request = $this->createUserRequest($userServiceCreateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceCreateUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceCreateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'createUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceCreateUserRequest $userServiceCreateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function createUserRequest($userServiceCreateUserRequest, string $contentType = self::contentTypes['createUser'][0])
    {

        if ($userServiceCreateUserRequest === null || (is_array($userServiceCreateUserRequest) && count($userServiceCreateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceCreateUserRequest when calling createUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/CreateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceCreateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceCreateUserRequest));
            } else {
                $httpBody = $userServiceCreateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deactivateUser
     *
     * DeactivateUser
     *
     * @param  \Zitadel\Client\Model\UserServiceDeactivateUserRequest $userServiceDeactivateUserRequest userServiceDeactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceDeactivateUserResponse
     * @throws ApiException
     */
    public function deactivateUser(    $userServiceDeactivateUserRequest,string $contentType = self::contentTypes['deactivateUser'][0])
    {
        $request = $this->deactivateUserRequest($userServiceDeactivateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceDeactivateUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceDeactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'deactivateUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceDeactivateUserRequest $userServiceDeactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function deactivateUserRequest($userServiceDeactivateUserRequest, string $contentType = self::contentTypes['deactivateUser'][0])
    {

        if ($userServiceDeactivateUserRequest === null || (is_array($userServiceDeactivateUserRequest) && count($userServiceDeactivateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceDeactivateUserRequest when calling deactivateUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/DeactivateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceDeactivateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceDeactivateUserRequest));
            } else {
                $httpBody = $userServiceDeactivateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUser
     *
     * DeleteUser
     *
     * @param  \Zitadel\Client\Model\UserServiceDeleteUserRequest $userServiceDeleteUserRequest userServiceDeleteUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceDeleteUserResponse
     * @throws ApiException
     */
    public function deleteUser(    $userServiceDeleteUserRequest,string $contentType = self::contentTypes['deleteUser'][0])
    {
        $request = $this->deleteUserRequest($userServiceDeleteUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceDeleteUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceDeleteUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'deleteUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceDeleteUserRequest $userServiceDeleteUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function deleteUserRequest($userServiceDeleteUserRequest, string $contentType = self::contentTypes['deleteUser'][0])
    {

        if ($userServiceDeleteUserRequest === null || (is_array($userServiceDeleteUserRequest) && count($userServiceDeleteUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceDeleteUserRequest when calling deleteUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/DeleteUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceDeleteUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceDeleteUserRequest));
            } else {
                $httpBody = $userServiceDeleteUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserMetadata
     *
     * DeleteUserMetadata
     *
     * @param  \Zitadel\Client\Model\UserServiceDeleteUserMetadataRequest $userServiceDeleteUserMetadataRequest userServiceDeleteUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMetadata'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceDeleteUserMetadataResponse
     * @throws ApiException
     */
    public function deleteUserMetadata(    $userServiceDeleteUserMetadataRequest,string $contentType = self::contentTypes['deleteUserMetadata'][0])
    {
        $request = $this->deleteUserMetadataRequest($userServiceDeleteUserMetadataRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceDeleteUserMetadataResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceDeleteUserMetadataResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'deleteUserMetadata'
     *
     * @param  \Zitadel\Client\Model\UserServiceDeleteUserMetadataRequest $userServiceDeleteUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function deleteUserMetadataRequest($userServiceDeleteUserMetadataRequest, string $contentType = self::contentTypes['deleteUserMetadata'][0])
    {

        if ($userServiceDeleteUserMetadataRequest === null || (is_array($userServiceDeleteUserMetadataRequest) && count($userServiceDeleteUserMetadataRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceDeleteUserMetadataRequest when calling deleteUserMetadata'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/DeleteUserMetadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceDeleteUserMetadataRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceDeleteUserMetadataRequest));
            } else {
                $httpBody = $userServiceDeleteUserMetadataRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUserByID
     *
     * GetUserByID
     *
     * @param  \Zitadel\Client\Model\UserServiceGetUserByIDRequest $userServiceGetUserByIDRequest userServiceGetUserByIDRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserByID'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceGetUserByIDResponse
     * @throws ApiException
     */
    public function getUserByID(    $userServiceGetUserByIDRequest,string $contentType = self::contentTypes['getUserByID'][0])
    {
        $request = $this->getUserByIDRequest($userServiceGetUserByIDRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceGetUserByIDResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceGetUserByIDResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'getUserByID'
     *
     * @param  \Zitadel\Client\Model\UserServiceGetUserByIDRequest $userServiceGetUserByIDRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUserByID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function getUserByIDRequest($userServiceGetUserByIDRequest, string $contentType = self::contentTypes['getUserByID'][0])
    {

        if ($userServiceGetUserByIDRequest === null || (is_array($userServiceGetUserByIDRequest) && count($userServiceGetUserByIDRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceGetUserByIDRequest when calling getUserByID'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/GetUserByID';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceGetUserByIDRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceGetUserByIDRequest));
            } else {
                $httpBody = $userServiceGetUserByIDRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation humanMFAInitSkipped
     *
     * HumanMFAInitSkipped
     *
     * @param  \Zitadel\Client\Model\UserServiceHumanMFAInitSkippedRequest $userServiceHumanMFAInitSkippedRequest userServiceHumanMFAInitSkippedRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['humanMFAInitSkipped'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse
     * @throws ApiException
     */
    public function humanMFAInitSkipped(    $userServiceHumanMFAInitSkippedRequest,string $contentType = self::contentTypes['humanMFAInitSkipped'][0])
    {
        $request = $this->humanMFAInitSkippedRequest($userServiceHumanMFAInitSkippedRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceHumanMFAInitSkippedResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'humanMFAInitSkipped'
     *
     * @param  \Zitadel\Client\Model\UserServiceHumanMFAInitSkippedRequest $userServiceHumanMFAInitSkippedRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['humanMFAInitSkipped'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function humanMFAInitSkippedRequest($userServiceHumanMFAInitSkippedRequest, string $contentType = self::contentTypes['humanMFAInitSkipped'][0])
    {

        if ($userServiceHumanMFAInitSkippedRequest === null || (is_array($userServiceHumanMFAInitSkippedRequest) && count($userServiceHumanMFAInitSkippedRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceHumanMFAInitSkippedRequest when calling humanMFAInitSkipped'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/HumanMFAInitSkipped';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceHumanMFAInitSkippedRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceHumanMFAInitSkippedRequest));
            } else {
                $httpBody = $userServiceHumanMFAInitSkippedRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAuthenticationFactors
     *
     * ListAuthenticationFactors
     *
     * @param  \Zitadel\Client\Model\UserServiceListAuthenticationFactorsRequest $userServiceListAuthenticationFactorsRequest userServiceListAuthenticationFactorsRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationFactors'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse
     * @throws ApiException
     */
    public function listAuthenticationFactors(    $userServiceListAuthenticationFactorsRequest,string $contentType = self::contentTypes['listAuthenticationFactors'][0])
    {
        $request = $this->listAuthenticationFactorsRequest($userServiceListAuthenticationFactorsRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListAuthenticationFactorsResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listAuthenticationFactors'
     *
     * @param  \Zitadel\Client\Model\UserServiceListAuthenticationFactorsRequest $userServiceListAuthenticationFactorsRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationFactors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listAuthenticationFactorsRequest($userServiceListAuthenticationFactorsRequest, string $contentType = self::contentTypes['listAuthenticationFactors'][0])
    {

        if ($userServiceListAuthenticationFactorsRequest === null || (is_array($userServiceListAuthenticationFactorsRequest) && count($userServiceListAuthenticationFactorsRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListAuthenticationFactorsRequest when calling listAuthenticationFactors'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListAuthenticationFactors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListAuthenticationFactorsRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListAuthenticationFactorsRequest));
            } else {
                $httpBody = $userServiceListAuthenticationFactorsRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAuthenticationMethodTypes
     *
     * ListAuthenticationMethodTypes
     *
     * @param  \Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesRequest $userServiceListAuthenticationMethodTypesRequest userServiceListAuthenticationMethodTypesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse
     * @throws ApiException
     */
    public function listAuthenticationMethodTypes(    $userServiceListAuthenticationMethodTypesRequest,string $contentType = self::contentTypes['listAuthenticationMethodTypes'][0])
    {
        $request = $this->listAuthenticationMethodTypesRequest($userServiceListAuthenticationMethodTypesRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listAuthenticationMethodTypes'
     *
     * @param  \Zitadel\Client\Model\UserServiceListAuthenticationMethodTypesRequest $userServiceListAuthenticationMethodTypesRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAuthenticationMethodTypes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listAuthenticationMethodTypesRequest($userServiceListAuthenticationMethodTypesRequest, string $contentType = self::contentTypes['listAuthenticationMethodTypes'][0])
    {

        if ($userServiceListAuthenticationMethodTypesRequest === null || (is_array($userServiceListAuthenticationMethodTypesRequest) && count($userServiceListAuthenticationMethodTypesRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListAuthenticationMethodTypesRequest when calling listAuthenticationMethodTypes'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListAuthenticationMethodTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListAuthenticationMethodTypesRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListAuthenticationMethodTypesRequest));
            } else {
                $httpBody = $userServiceListAuthenticationMethodTypesRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIDPLinks
     *
     * ListIDPLinks
     *
     * @param  \Zitadel\Client\Model\UserServiceListIDPLinksRequest $userServiceListIDPLinksRequest userServiceListIDPLinksRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIDPLinks'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListIDPLinksResponse
     * @throws ApiException
     */
    public function listIDPLinks(    $userServiceListIDPLinksRequest,string $contentType = self::contentTypes['listIDPLinks'][0])
    {
        $request = $this->listIDPLinksRequest($userServiceListIDPLinksRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListIDPLinksResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListIDPLinksResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listIDPLinks'
     *
     * @param  \Zitadel\Client\Model\UserServiceListIDPLinksRequest $userServiceListIDPLinksRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIDPLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listIDPLinksRequest($userServiceListIDPLinksRequest, string $contentType = self::contentTypes['listIDPLinks'][0])
    {

        if ($userServiceListIDPLinksRequest === null || (is_array($userServiceListIDPLinksRequest) && count($userServiceListIDPLinksRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListIDPLinksRequest when calling listIDPLinks'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListIDPLinks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListIDPLinksRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListIDPLinksRequest));
            } else {
                $httpBody = $userServiceListIDPLinksRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listKeys
     *
     * ListKeys
     *
     * @param  \Zitadel\Client\Model\UserServiceListKeysRequest $userServiceListKeysRequest userServiceListKeysRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listKeys'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListKeysResponse
     * @throws ApiException
     */
    public function listKeys(    $userServiceListKeysRequest,string $contentType = self::contentTypes['listKeys'][0])
    {
        $request = $this->listKeysRequest($userServiceListKeysRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListKeysResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListKeysResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listKeys'
     *
     * @param  \Zitadel\Client\Model\UserServiceListKeysRequest $userServiceListKeysRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listKeysRequest($userServiceListKeysRequest, string $contentType = self::contentTypes['listKeys'][0])
    {

        if ($userServiceListKeysRequest === null || (is_array($userServiceListKeysRequest) && count($userServiceListKeysRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListKeysRequest when calling listKeys'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListKeys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListKeysRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListKeysRequest));
            } else {
                $httpBody = $userServiceListKeysRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPasskeys
     *
     * ListPasskeys
     *
     * @param  \Zitadel\Client\Model\UserServiceListPasskeysRequest $userServiceListPasskeysRequest userServiceListPasskeysRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPasskeys'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListPasskeysResponse
     * @throws ApiException
     */
    public function listPasskeys(    $userServiceListPasskeysRequest,string $contentType = self::contentTypes['listPasskeys'][0])
    {
        $request = $this->listPasskeysRequest($userServiceListPasskeysRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListPasskeysResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListPasskeysResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listPasskeys'
     *
     * @param  \Zitadel\Client\Model\UserServiceListPasskeysRequest $userServiceListPasskeysRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPasskeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listPasskeysRequest($userServiceListPasskeysRequest, string $contentType = self::contentTypes['listPasskeys'][0])
    {

        if ($userServiceListPasskeysRequest === null || (is_array($userServiceListPasskeysRequest) && count($userServiceListPasskeysRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListPasskeysRequest when calling listPasskeys'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListPasskeys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListPasskeysRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListPasskeysRequest));
            } else {
                $httpBody = $userServiceListPasskeysRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPersonalAccessTokens
     *
     * ListPersonalAccessTokens
     *
     * @param  \Zitadel\Client\Model\UserServiceListPersonalAccessTokensRequest $userServiceListPersonalAccessTokensRequest userServiceListPersonalAccessTokensRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPersonalAccessTokens'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListPersonalAccessTokensResponse
     * @throws ApiException
     */
    public function listPersonalAccessTokens(    $userServiceListPersonalAccessTokensRequest,string $contentType = self::contentTypes['listPersonalAccessTokens'][0])
    {
        $request = $this->listPersonalAccessTokensRequest($userServiceListPersonalAccessTokensRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListPersonalAccessTokensResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListPersonalAccessTokensResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listPersonalAccessTokens'
     *
     * @param  \Zitadel\Client\Model\UserServiceListPersonalAccessTokensRequest $userServiceListPersonalAccessTokensRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listPersonalAccessTokensRequest($userServiceListPersonalAccessTokensRequest, string $contentType = self::contentTypes['listPersonalAccessTokens'][0])
    {

        if ($userServiceListPersonalAccessTokensRequest === null || (is_array($userServiceListPersonalAccessTokensRequest) && count($userServiceListPersonalAccessTokensRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListPersonalAccessTokensRequest when calling listPersonalAccessTokens'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListPersonalAccessTokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListPersonalAccessTokensRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListPersonalAccessTokensRequest));
            } else {
                $httpBody = $userServiceListPersonalAccessTokensRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUserMetadata
     *
     * ListUserMetadata
     *
     * @param  \Zitadel\Client\Model\UserServiceListUserMetadataRequest $userServiceListUserMetadataRequest userServiceListUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserMetadata'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListUserMetadataResponse
     * @throws ApiException
     */
    public function listUserMetadata(    $userServiceListUserMetadataRequest,string $contentType = self::contentTypes['listUserMetadata'][0])
    {
        $request = $this->listUserMetadataRequest($userServiceListUserMetadataRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListUserMetadataResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListUserMetadataResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listUserMetadata'
     *
     * @param  \Zitadel\Client\Model\UserServiceListUserMetadataRequest $userServiceListUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUserMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listUserMetadataRequest($userServiceListUserMetadataRequest, string $contentType = self::contentTypes['listUserMetadata'][0])
    {

        if ($userServiceListUserMetadataRequest === null || (is_array($userServiceListUserMetadataRequest) && count($userServiceListUserMetadataRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListUserMetadataRequest when calling listUserMetadata'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListUserMetadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListUserMetadataRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListUserMetadataRequest));
            } else {
                $httpBody = $userServiceListUserMetadataRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listUsers
     *
     * ListUsers
     *
     * @param  \Zitadel\Client\Model\UserServiceListUsersRequest $userServiceListUsersRequest userServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceListUsersResponse
     * @throws ApiException
     */
    public function listUsers(    $userServiceListUsersRequest,string $contentType = self::contentTypes['listUsers'][0])
    {
        $request = $this->listUsersRequest($userServiceListUsersRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceListUsersResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceListUsersResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'listUsers'
     *
     * @param  \Zitadel\Client\Model\UserServiceListUsersRequest $userServiceListUsersRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function listUsersRequest($userServiceListUsersRequest, string $contentType = self::contentTypes['listUsers'][0])
    {

        if ($userServiceListUsersRequest === null || (is_array($userServiceListUsersRequest) && count($userServiceListUsersRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceListUsersRequest when calling listUsers'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ListUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceListUsersRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceListUsersRequest));
            } else {
                $httpBody = $userServiceListUsersRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockUser
     *
     * LockUser
     *
     * @param  \Zitadel\Client\Model\UserServiceLockUserRequest $userServiceLockUserRequest userServiceLockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceLockUserResponse
     * @throws ApiException
     */
    public function lockUser(    $userServiceLockUserRequest,string $contentType = self::contentTypes['lockUser'][0])
    {
        $request = $this->lockUserRequest($userServiceLockUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceLockUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceLockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'lockUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceLockUserRequest $userServiceLockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function lockUserRequest($userServiceLockUserRequest, string $contentType = self::contentTypes['lockUser'][0])
    {

        if ($userServiceLockUserRequest === null || (is_array($userServiceLockUserRequest) && count($userServiceLockUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceLockUserRequest when calling lockUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/LockUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceLockUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceLockUserRequest));
            } else {
                $httpBody = $userServiceLockUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation noOp
     *
     * Dummy endpoint to retain union-member schemas
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['noOp'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\NoOp200Response6
     * @throws ApiException
     */
    public function noOp(string $contentType = self::contentTypes['noOp'][0])
    {
        $request = $this->noOpRequest($contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\NoOp200Response6',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\NoOp200Response6';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'noOp'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['noOp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function noOpRequest(string $contentType = self::contentTypes['noOp'][0])
    {


        $resourcePath = '/06d79fa5';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation passwordReset
     *
     * PasswordReset
     *
     * @param  \Zitadel\Client\Model\UserServicePasswordResetRequest $userServicePasswordResetRequest userServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['passwordReset'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServicePasswordResetResponse
     * @throws ApiException
     */
    public function passwordReset(    $userServicePasswordResetRequest,string $contentType = self::contentTypes['passwordReset'][0])
    {
        $request = $this->passwordResetRequest($userServicePasswordResetRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServicePasswordResetResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServicePasswordResetResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'passwordReset'
     *
     * @param  \Zitadel\Client\Model\UserServicePasswordResetRequest $userServicePasswordResetRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['passwordReset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function passwordResetRequest($userServicePasswordResetRequest, string $contentType = self::contentTypes['passwordReset'][0])
    {

        if ($userServicePasswordResetRequest === null || (is_array($userServicePasswordResetRequest) && count($userServicePasswordResetRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServicePasswordResetRequest when calling passwordReset'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/PasswordReset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServicePasswordResetRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServicePasswordResetRequest));
            } else {
                $httpBody = $userServicePasswordResetRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reactivateUser
     *
     * ReactivateUser
     *
     * @param  \Zitadel\Client\Model\UserServiceReactivateUserRequest $userServiceReactivateUserRequest userServiceReactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reactivateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceReactivateUserResponse
     * @throws ApiException
     */
    public function reactivateUser(    $userServiceReactivateUserRequest,string $contentType = self::contentTypes['reactivateUser'][0])
    {
        $request = $this->reactivateUserRequest($userServiceReactivateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceReactivateUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceReactivateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'reactivateUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceReactivateUserRequest $userServiceReactivateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reactivateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function reactivateUserRequest($userServiceReactivateUserRequest, string $contentType = self::contentTypes['reactivateUser'][0])
    {

        if ($userServiceReactivateUserRequest === null || (is_array($userServiceReactivateUserRequest) && count($userServiceReactivateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceReactivateUserRequest when calling reactivateUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ReactivateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceReactivateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceReactivateUserRequest));
            } else {
                $httpBody = $userServiceReactivateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerPasskey
     *
     * RegisterPasskey
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterPasskeyRequest $userServiceRegisterPasskeyRequest userServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerPasskey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterPasskeyResponse
     * @throws ApiException
     */
    public function registerPasskey(    $userServiceRegisterPasskeyRequest,string $contentType = self::contentTypes['registerPasskey'][0])
    {
        $request = $this->registerPasskeyRequest($userServiceRegisterPasskeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterPasskeyResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterPasskeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerPasskey'
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterPasskeyRequest $userServiceRegisterPasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerPasskey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerPasskeyRequest($userServiceRegisterPasskeyRequest, string $contentType = self::contentTypes['registerPasskey'][0])
    {

        if ($userServiceRegisterPasskeyRequest === null || (is_array($userServiceRegisterPasskeyRequest) && count($userServiceRegisterPasskeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRegisterPasskeyRequest when calling registerPasskey'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RegisterPasskey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRegisterPasskeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRegisterPasskeyRequest));
            } else {
                $httpBody = $userServiceRegisterPasskeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerTOTP
     *
     * RegisterTOTP
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterTOTPRequest $userServiceRegisterTOTPRequest userServiceRegisterTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterTOTPResponse
     * @throws ApiException
     */
    public function registerTOTP(    $userServiceRegisterTOTPRequest,string $contentType = self::contentTypes['registerTOTP'][0])
    {
        $request = $this->registerTOTPRequest($userServiceRegisterTOTPRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterTOTPResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerTOTP'
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterTOTPRequest $userServiceRegisterTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerTOTPRequest($userServiceRegisterTOTPRequest, string $contentType = self::contentTypes['registerTOTP'][0])
    {

        if ($userServiceRegisterTOTPRequest === null || (is_array($userServiceRegisterTOTPRequest) && count($userServiceRegisterTOTPRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRegisterTOTPRequest when calling registerTOTP'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RegisterTOTP';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRegisterTOTPRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRegisterTOTPRequest));
            } else {
                $httpBody = $userServiceRegisterTOTPRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerU2F
     *
     * RegisterU2F
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterU2FRequest $userServiceRegisterU2FRequest userServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerU2F'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRegisterU2FResponse
     * @throws ApiException
     */
    public function registerU2F(    $userServiceRegisterU2FRequest,string $contentType = self::contentTypes['registerU2F'][0])
    {
        $request = $this->registerU2FRequest($userServiceRegisterU2FRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRegisterU2FResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRegisterU2FResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'registerU2F'
     *
     * @param  \Zitadel\Client\Model\UserServiceRegisterU2FRequest $userServiceRegisterU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['registerU2F'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function registerU2FRequest($userServiceRegisterU2FRequest, string $contentType = self::contentTypes['registerU2F'][0])
    {

        if ($userServiceRegisterU2FRequest === null || (is_array($userServiceRegisterU2FRequest) && count($userServiceRegisterU2FRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRegisterU2FRequest when calling registerU2F'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RegisterU2F';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRegisterU2FRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRegisterU2FRequest));
            } else {
                $httpBody = $userServiceRegisterU2FRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeIDPLink
     *
     * RemoveIDPLink
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveIDPLinkRequest $userServiceRemoveIDPLinkRequest userServiceRemoveIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeIDPLink'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse
     * @throws ApiException
     */
    public function removeIDPLink(    $userServiceRemoveIDPLinkRequest,string $contentType = self::contentTypes['removeIDPLink'][0])
    {
        $request = $this->removeIDPLinkRequest($userServiceRemoveIDPLinkRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveIDPLinkResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeIDPLink'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveIDPLinkRequest $userServiceRemoveIDPLinkRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeIDPLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeIDPLinkRequest($userServiceRemoveIDPLinkRequest, string $contentType = self::contentTypes['removeIDPLink'][0])
    {

        if ($userServiceRemoveIDPLinkRequest === null || (is_array($userServiceRemoveIDPLinkRequest) && count($userServiceRemoveIDPLinkRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveIDPLinkRequest when calling removeIDPLink'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveIDPLink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveIDPLinkRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveIDPLinkRequest));
            } else {
                $httpBody = $userServiceRemoveIDPLinkRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeKey
     *
     * RemoveKey
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveKeyRequest $userServiceRemoveKeyRequest userServiceRemoveKeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeKey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveKeyResponse
     * @throws ApiException
     */
    public function removeKey(    $userServiceRemoveKeyRequest,string $contentType = self::contentTypes['removeKey'][0])
    {
        $request = $this->removeKeyRequest($userServiceRemoveKeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveKeyResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveKeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeKey'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveKeyRequest $userServiceRemoveKeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeKeyRequest($userServiceRemoveKeyRequest, string $contentType = self::contentTypes['removeKey'][0])
    {

        if ($userServiceRemoveKeyRequest === null || (is_array($userServiceRemoveKeyRequest) && count($userServiceRemoveKeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveKeyRequest when calling removeKey'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveKey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveKeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveKeyRequest));
            } else {
                $httpBody = $userServiceRemoveKeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeOTPEmail
     *
     * RemoveOTPEmail
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveOTPEmailRequest $userServiceRemoveOTPEmailRequest userServiceRemoveOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse
     * @throws ApiException
     */
    public function removeOTPEmail(    $userServiceRemoveOTPEmailRequest,string $contentType = self::contentTypes['removeOTPEmail'][0])
    {
        $request = $this->removeOTPEmailRequest($userServiceRemoveOTPEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveOTPEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeOTPEmail'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveOTPEmailRequest $userServiceRemoveOTPEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeOTPEmailRequest($userServiceRemoveOTPEmailRequest, string $contentType = self::contentTypes['removeOTPEmail'][0])
    {

        if ($userServiceRemoveOTPEmailRequest === null || (is_array($userServiceRemoveOTPEmailRequest) && count($userServiceRemoveOTPEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveOTPEmailRequest when calling removeOTPEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveOTPEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveOTPEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveOTPEmailRequest));
            } else {
                $httpBody = $userServiceRemoveOTPEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeOTPSMS
     *
     * RemoveOTPSMS
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveOTPSMSRequest $userServiceRemoveOTPSMSRequest userServiceRemoveOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPSMS'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse
     * @throws ApiException
     */
    public function removeOTPSMS(    $userServiceRemoveOTPSMSRequest,string $contentType = self::contentTypes['removeOTPSMS'][0])
    {
        $request = $this->removeOTPSMSRequest($userServiceRemoveOTPSMSRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveOTPSMSResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeOTPSMS'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveOTPSMSRequest $userServiceRemoveOTPSMSRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeOTPSMS'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeOTPSMSRequest($userServiceRemoveOTPSMSRequest, string $contentType = self::contentTypes['removeOTPSMS'][0])
    {

        if ($userServiceRemoveOTPSMSRequest === null || (is_array($userServiceRemoveOTPSMSRequest) && count($userServiceRemoveOTPSMSRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveOTPSMSRequest when calling removeOTPSMS'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveOTPSMS';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveOTPSMSRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveOTPSMSRequest));
            } else {
                $httpBody = $userServiceRemoveOTPSMSRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePasskey
     *
     * RemovePasskey
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePasskeyRequest $userServiceRemovePasskeyRequest userServiceRemovePasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePasskey'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemovePasskeyResponse
     * @throws ApiException
     */
    public function removePasskey(    $userServiceRemovePasskeyRequest,string $contentType = self::contentTypes['removePasskey'][0])
    {
        $request = $this->removePasskeyRequest($userServiceRemovePasskeyRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemovePasskeyResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemovePasskeyResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removePasskey'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePasskeyRequest $userServiceRemovePasskeyRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePasskey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removePasskeyRequest($userServiceRemovePasskeyRequest, string $contentType = self::contentTypes['removePasskey'][0])
    {

        if ($userServiceRemovePasskeyRequest === null || (is_array($userServiceRemovePasskeyRequest) && count($userServiceRemovePasskeyRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemovePasskeyRequest when calling removePasskey'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemovePasskey';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemovePasskeyRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemovePasskeyRequest));
            } else {
                $httpBody = $userServiceRemovePasskeyRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePersonalAccessToken
     *
     * RemovePersonalAccessToken
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePersonalAccessTokenRequest $userServiceRemovePersonalAccessTokenRequest userServiceRemovePersonalAccessTokenRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePersonalAccessToken'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemovePersonalAccessTokenResponse
     * @throws ApiException
     */
    public function removePersonalAccessToken(    $userServiceRemovePersonalAccessTokenRequest,string $contentType = self::contentTypes['removePersonalAccessToken'][0])
    {
        $request = $this->removePersonalAccessTokenRequest($userServiceRemovePersonalAccessTokenRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemovePersonalAccessTokenResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemovePersonalAccessTokenResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removePersonalAccessToken'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePersonalAccessTokenRequest $userServiceRemovePersonalAccessTokenRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removePersonalAccessTokenRequest($userServiceRemovePersonalAccessTokenRequest, string $contentType = self::contentTypes['removePersonalAccessToken'][0])
    {

        if ($userServiceRemovePersonalAccessTokenRequest === null || (is_array($userServiceRemovePersonalAccessTokenRequest) && count($userServiceRemovePersonalAccessTokenRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemovePersonalAccessTokenRequest when calling removePersonalAccessToken'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemovePersonalAccessToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemovePersonalAccessTokenRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemovePersonalAccessTokenRequest));
            } else {
                $httpBody = $userServiceRemovePersonalAccessTokenRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removePhone
     *
     * RemovePhone
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePhoneRequest $userServiceRemovePhoneRequest userServiceRemovePhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemovePhoneResponse
     * @throws ApiException
     */
    public function removePhone(    $userServiceRemovePhoneRequest,string $contentType = self::contentTypes['removePhone'][0])
    {
        $request = $this->removePhoneRequest($userServiceRemovePhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemovePhoneResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemovePhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removePhone'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemovePhoneRequest $userServiceRemovePhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removePhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removePhoneRequest($userServiceRemovePhoneRequest, string $contentType = self::contentTypes['removePhone'][0])
    {

        if ($userServiceRemovePhoneRequest === null || (is_array($userServiceRemovePhoneRequest) && count($userServiceRemovePhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemovePhoneRequest when calling removePhone'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemovePhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemovePhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemovePhoneRequest));
            } else {
                $httpBody = $userServiceRemovePhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeSecret
     *
     * RemoveSecret
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveSecretRequest $userServiceRemoveSecretRequest userServiceRemoveSecretRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeSecret'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveSecretResponse
     * @throws ApiException
     */
    public function removeSecret(    $userServiceRemoveSecretRequest,string $contentType = self::contentTypes['removeSecret'][0])
    {
        $request = $this->removeSecretRequest($userServiceRemoveSecretRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveSecretResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveSecretResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeSecret'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveSecretRequest $userServiceRemoveSecretRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeSecretRequest($userServiceRemoveSecretRequest, string $contentType = self::contentTypes['removeSecret'][0])
    {

        if ($userServiceRemoveSecretRequest === null || (is_array($userServiceRemoveSecretRequest) && count($userServiceRemoveSecretRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveSecretRequest when calling removeSecret'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveSecret';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveSecretRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveSecretRequest));
            } else {
                $httpBody = $userServiceRemoveSecretRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeTOTP
     *
     * RemoveTOTP
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveTOTPRequest $userServiceRemoveTOTPRequest userServiceRemoveTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeTOTP'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveTOTPResponse
     * @throws ApiException
     */
    public function removeTOTP(    $userServiceRemoveTOTPRequest,string $contentType = self::contentTypes['removeTOTP'][0])
    {
        $request = $this->removeTOTPRequest($userServiceRemoveTOTPRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveTOTPResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveTOTPResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeTOTP'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveTOTPRequest $userServiceRemoveTOTPRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeTOTP'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeTOTPRequest($userServiceRemoveTOTPRequest, string $contentType = self::contentTypes['removeTOTP'][0])
    {

        if ($userServiceRemoveTOTPRequest === null || (is_array($userServiceRemoveTOTPRequest) && count($userServiceRemoveTOTPRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveTOTPRequest when calling removeTOTP'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveTOTP';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveTOTPRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveTOTPRequest));
            } else {
                $httpBody = $userServiceRemoveTOTPRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeU2F
     *
     * RemoveU2F
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveU2FRequest $userServiceRemoveU2FRequest userServiceRemoveU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeU2F'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRemoveU2FResponse
     * @throws ApiException
     */
    public function removeU2F(    $userServiceRemoveU2FRequest,string $contentType = self::contentTypes['removeU2F'][0])
    {
        $request = $this->removeU2FRequest($userServiceRemoveU2FRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRemoveU2FResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRemoveU2FResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'removeU2F'
     *
     * @param  \Zitadel\Client\Model\UserServiceRemoveU2FRequest $userServiceRemoveU2FRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['removeU2F'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function removeU2FRequest($userServiceRemoveU2FRequest, string $contentType = self::contentTypes['removeU2F'][0])
    {

        if ($userServiceRemoveU2FRequest === null || (is_array($userServiceRemoveU2FRequest) && count($userServiceRemoveU2FRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRemoveU2FRequest when calling removeU2F'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RemoveU2F';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRemoveU2FRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRemoveU2FRequest));
            } else {
                $httpBody = $userServiceRemoveU2FRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendEmailCode
     *
     * ResendEmailCode
     *
     * @param  \Zitadel\Client\Model\UserServiceResendEmailCodeRequest $userServiceResendEmailCodeRequest userServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendEmailCodeResponse
     * @throws ApiException
     */
    public function resendEmailCode(    $userServiceResendEmailCodeRequest,string $contentType = self::contentTypes['resendEmailCode'][0])
    {
        $request = $this->resendEmailCodeRequest($userServiceResendEmailCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendEmailCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendEmailCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'resendEmailCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceResendEmailCodeRequest $userServiceResendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function resendEmailCodeRequest($userServiceResendEmailCodeRequest, string $contentType = self::contentTypes['resendEmailCode'][0])
    {

        if ($userServiceResendEmailCodeRequest === null || (is_array($userServiceResendEmailCodeRequest) && count($userServiceResendEmailCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceResendEmailCodeRequest when calling resendEmailCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ResendEmailCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceResendEmailCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceResendEmailCodeRequest));
            } else {
                $httpBody = $userServiceResendEmailCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendInviteCode
     *
     * ResendInviteCode
     *
     * @param  \Zitadel\Client\Model\UserServiceResendInviteCodeRequest $userServiceResendInviteCodeRequest userServiceResendInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendInviteCodeResponse
     * @throws ApiException
     */
    public function resendInviteCode(    $userServiceResendInviteCodeRequest,string $contentType = self::contentTypes['resendInviteCode'][0])
    {
        $request = $this->resendInviteCodeRequest($userServiceResendInviteCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendInviteCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'resendInviteCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceResendInviteCodeRequest $userServiceResendInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function resendInviteCodeRequest($userServiceResendInviteCodeRequest, string $contentType = self::contentTypes['resendInviteCode'][0])
    {

        if ($userServiceResendInviteCodeRequest === null || (is_array($userServiceResendInviteCodeRequest) && count($userServiceResendInviteCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceResendInviteCodeRequest when calling resendInviteCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ResendInviteCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceResendInviteCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceResendInviteCodeRequest));
            } else {
                $httpBody = $userServiceResendInviteCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendPhoneCode
     *
     * ResendPhoneCode
     *
     * @param  \Zitadel\Client\Model\UserServiceResendPhoneCodeRequest $userServiceResendPhoneCodeRequest userServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendPhoneCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceResendPhoneCodeResponse
     * @throws ApiException
     */
    public function resendPhoneCode(    $userServiceResendPhoneCodeRequest,string $contentType = self::contentTypes['resendPhoneCode'][0])
    {
        $request = $this->resendPhoneCodeRequest($userServiceResendPhoneCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceResendPhoneCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceResendPhoneCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'resendPhoneCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceResendPhoneCodeRequest $userServiceResendPhoneCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendPhoneCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function resendPhoneCodeRequest($userServiceResendPhoneCodeRequest, string $contentType = self::contentTypes['resendPhoneCode'][0])
    {

        if ($userServiceResendPhoneCodeRequest === null || (is_array($userServiceResendPhoneCodeRequest) && count($userServiceResendPhoneCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceResendPhoneCodeRequest when calling resendPhoneCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/ResendPhoneCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceResendPhoneCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceResendPhoneCodeRequest));
            } else {
                $httpBody = $userServiceResendPhoneCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveIdentityProviderIntent
     *
     * RetrieveIdentityProviderIntent
     *
     * @param  \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentRequest $userServiceRetrieveIdentityProviderIntentRequest userServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function retrieveIdentityProviderIntent(    $userServiceRetrieveIdentityProviderIntentRequest,string $contentType = self::contentTypes['retrieveIdentityProviderIntent'][0])
    {
        $request = $this->retrieveIdentityProviderIntentRequest($userServiceRetrieveIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'retrieveIdentityProviderIntent'
     *
     * @param  \Zitadel\Client\Model\UserServiceRetrieveIdentityProviderIntentRequest $userServiceRetrieveIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function retrieveIdentityProviderIntentRequest($userServiceRetrieveIdentityProviderIntentRequest, string $contentType = self::contentTypes['retrieveIdentityProviderIntent'][0])
    {

        if ($userServiceRetrieveIdentityProviderIntentRequest === null || (is_array($userServiceRetrieveIdentityProviderIntentRequest) && count($userServiceRetrieveIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceRetrieveIdentityProviderIntentRequest when calling retrieveIdentityProviderIntent'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/RetrieveIdentityProviderIntent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceRetrieveIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceRetrieveIdentityProviderIntentRequest));
            } else {
                $httpBody = $userServiceRetrieveIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendEmailCode
     *
     * SendEmailCode
     *
     * @param  \Zitadel\Client\Model\UserServiceSendEmailCodeRequest $userServiceSendEmailCodeRequest userServiceSendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSendEmailCodeResponse
     * @throws ApiException
     */
    public function sendEmailCode(    $userServiceSendEmailCodeRequest,string $contentType = self::contentTypes['sendEmailCode'][0])
    {
        $request = $this->sendEmailCodeRequest($userServiceSendEmailCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSendEmailCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSendEmailCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'sendEmailCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceSendEmailCodeRequest $userServiceSendEmailCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function sendEmailCodeRequest($userServiceSendEmailCodeRequest, string $contentType = self::contentTypes['sendEmailCode'][0])
    {

        if ($userServiceSendEmailCodeRequest === null || (is_array($userServiceSendEmailCodeRequest) && count($userServiceSendEmailCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSendEmailCodeRequest when calling sendEmailCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/SendEmailCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSendEmailCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSendEmailCodeRequest));
            } else {
                $httpBody = $userServiceSendEmailCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setEmail
     *
     * SetEmail
     *
     * @param  \Zitadel\Client\Model\UserServiceSetEmailRequest $userServiceSetEmailRequest userServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetEmailResponse
     * @throws ApiException
     */
    public function setEmail(    $userServiceSetEmailRequest,string $contentType = self::contentTypes['setEmail'][0])
    {
        $request = $this->setEmailRequest($userServiceSetEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetEmailResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setEmail'
     *
     * @param  \Zitadel\Client\Model\UserServiceSetEmailRequest $userServiceSetEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setEmailRequest($userServiceSetEmailRequest, string $contentType = self::contentTypes['setEmail'][0])
    {

        if ($userServiceSetEmailRequest === null || (is_array($userServiceSetEmailRequest) && count($userServiceSetEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetEmailRequest when calling setEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/SetEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetEmailRequest));
            } else {
                $httpBody = $userServiceSetEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPassword
     *
     * SetPassword
     *
     * @param  \Zitadel\Client\Model\UserServiceSetPasswordRequest $userServiceSetPasswordRequest userServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPassword'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetPasswordResponse
     * @throws ApiException
     */
    public function setPassword(    $userServiceSetPasswordRequest,string $contentType = self::contentTypes['setPassword'][0])
    {
        $request = $this->setPasswordRequest($userServiceSetPasswordRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetPasswordResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetPasswordResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setPassword'
     *
     * @param  \Zitadel\Client\Model\UserServiceSetPasswordRequest $userServiceSetPasswordRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPassword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setPasswordRequest($userServiceSetPasswordRequest, string $contentType = self::contentTypes['setPassword'][0])
    {

        if ($userServiceSetPasswordRequest === null || (is_array($userServiceSetPasswordRequest) && count($userServiceSetPasswordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetPasswordRequest when calling setPassword'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/SetPassword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetPasswordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetPasswordRequest));
            } else {
                $httpBody = $userServiceSetPasswordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPhone
     *
     * SetPhone
     *
     * @param  \Zitadel\Client\Model\UserServiceSetPhoneRequest $userServiceSetPhoneRequest userServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetPhoneResponse
     * @throws ApiException
     */
    public function setPhone(    $userServiceSetPhoneRequest,string $contentType = self::contentTypes['setPhone'][0])
    {
        $request = $this->setPhoneRequest($userServiceSetPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetPhoneResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setPhone'
     *
     * @param  \Zitadel\Client\Model\UserServiceSetPhoneRequest $userServiceSetPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setPhoneRequest($userServiceSetPhoneRequest, string $contentType = self::contentTypes['setPhone'][0])
    {

        if ($userServiceSetPhoneRequest === null || (is_array($userServiceSetPhoneRequest) && count($userServiceSetPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetPhoneRequest when calling setPhone'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/SetPhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetPhoneRequest));
            } else {
                $httpBody = $userServiceSetPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setUserMetadata
     *
     * SetUserMetadata
     *
     * @param  \Zitadel\Client\Model\UserServiceSetUserMetadataRequest $userServiceSetUserMetadataRequest userServiceSetUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setUserMetadata'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceSetUserMetadataResponse
     * @throws ApiException
     */
    public function setUserMetadata(    $userServiceSetUserMetadataRequest,string $contentType = self::contentTypes['setUserMetadata'][0])
    {
        $request = $this->setUserMetadataRequest($userServiceSetUserMetadataRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceSetUserMetadataResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceSetUserMetadataResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'setUserMetadata'
     *
     * @param  \Zitadel\Client\Model\UserServiceSetUserMetadataRequest $userServiceSetUserMetadataRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setUserMetadata'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function setUserMetadataRequest($userServiceSetUserMetadataRequest, string $contentType = self::contentTypes['setUserMetadata'][0])
    {

        if ($userServiceSetUserMetadataRequest === null || (is_array($userServiceSetUserMetadataRequest) && count($userServiceSetUserMetadataRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceSetUserMetadataRequest when calling setUserMetadata'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/SetUserMetadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceSetUserMetadataRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceSetUserMetadataRequest));
            } else {
                $httpBody = $userServiceSetUserMetadataRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startIdentityProviderIntent
     *
     * StartIdentityProviderIntent
     *
     * @param  \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentRequest $userServiceStartIdentityProviderIntentRequest userServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startIdentityProviderIntent'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse
     * @throws ApiException
     */
    public function startIdentityProviderIntent(    $userServiceStartIdentityProviderIntentRequest,string $contentType = self::contentTypes['startIdentityProviderIntent'][0])
    {
        $request = $this->startIdentityProviderIntentRequest($userServiceStartIdentityProviderIntentRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceStartIdentityProviderIntentResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'startIdentityProviderIntent'
     *
     * @param  \Zitadel\Client\Model\UserServiceStartIdentityProviderIntentRequest $userServiceStartIdentityProviderIntentRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startIdentityProviderIntent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function startIdentityProviderIntentRequest($userServiceStartIdentityProviderIntentRequest, string $contentType = self::contentTypes['startIdentityProviderIntent'][0])
    {

        if ($userServiceStartIdentityProviderIntentRequest === null || (is_array($userServiceStartIdentityProviderIntentRequest) && count($userServiceStartIdentityProviderIntentRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceStartIdentityProviderIntentRequest when calling startIdentityProviderIntent'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/StartIdentityProviderIntent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceStartIdentityProviderIntentRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceStartIdentityProviderIntentRequest));
            } else {
                $httpBody = $userServiceStartIdentityProviderIntentRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockUser
     *
     * UnlockUser
     *
     * @param  \Zitadel\Client\Model\UserServiceUnlockUserRequest $userServiceUnlockUserRequest userServiceUnlockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceUnlockUserResponse
     * @throws ApiException
     */
    public function unlockUser(    $userServiceUnlockUserRequest,string $contentType = self::contentTypes['unlockUser'][0])
    {
        $request = $this->unlockUserRequest($userServiceUnlockUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceUnlockUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceUnlockUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'unlockUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceUnlockUserRequest $userServiceUnlockUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function unlockUserRequest($userServiceUnlockUserRequest, string $contentType = self::contentTypes['unlockUser'][0])
    {

        if ($userServiceUnlockUserRequest === null || (is_array($userServiceUnlockUserRequest) && count($userServiceUnlockUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceUnlockUserRequest when calling unlockUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/UnlockUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceUnlockUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceUnlockUserRequest));
            } else {
                $httpBody = $userServiceUnlockUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHumanUser
     *
     * UpdateHumanUser
     *
     * @param  \Zitadel\Client\Model\UserServiceUpdateHumanUserRequest $userServiceUpdateHumanUserRequest userServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHumanUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceUpdateHumanUserResponse
     * @throws ApiException
     */
    public function updateHumanUser(    $userServiceUpdateHumanUserRequest,string $contentType = self::contentTypes['updateHumanUser'][0])
    {
        $request = $this->updateHumanUserRequest($userServiceUpdateHumanUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceUpdateHumanUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceUpdateHumanUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'updateHumanUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceUpdateHumanUserRequest $userServiceUpdateHumanUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHumanUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function updateHumanUserRequest($userServiceUpdateHumanUserRequest, string $contentType = self::contentTypes['updateHumanUser'][0])
    {

        if ($userServiceUpdateHumanUserRequest === null || (is_array($userServiceUpdateHumanUserRequest) && count($userServiceUpdateHumanUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceUpdateHumanUserRequest when calling updateHumanUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/UpdateHumanUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceUpdateHumanUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceUpdateHumanUserRequest));
            } else {
                $httpBody = $userServiceUpdateHumanUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateUser
     *
     * UpdateUser
     *
     * @param  \Zitadel\Client\Model\UserServiceUpdateUserRequest $userServiceUpdateUserRequest userServiceUpdateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceUpdateUserResponse
     * @throws ApiException
     */
    public function updateUser(    $userServiceUpdateUserRequest,string $contentType = self::contentTypes['updateUser'][0])
    {
        $request = $this->updateUserRequest($userServiceUpdateUserRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceUpdateUserResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceUpdateUserResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'updateUser'
     *
     * @param  \Zitadel\Client\Model\UserServiceUpdateUserRequest $userServiceUpdateUserRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function updateUserRequest($userServiceUpdateUserRequest, string $contentType = self::contentTypes['updateUser'][0])
    {

        if ($userServiceUpdateUserRequest === null || (is_array($userServiceUpdateUserRequest) && count($userServiceUpdateUserRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceUpdateUserRequest when calling updateUser'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/UpdateUser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceUpdateUserRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceUpdateUserRequest));
            } else {
                $httpBody = $userServiceUpdateUserRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyEmail
     *
     * VerifyEmail
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyEmailRequest $userServiceVerifyEmailRequest userServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyEmail'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyEmailResponse
     * @throws ApiException
     */
    public function verifyEmail(    $userServiceVerifyEmailRequest,string $contentType = self::contentTypes['verifyEmail'][0])
    {
        $request = $this->verifyEmailRequest($userServiceVerifyEmailRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyEmailResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyEmailResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyEmail'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyEmailRequest $userServiceVerifyEmailRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyEmailRequest($userServiceVerifyEmailRequest, string $contentType = self::contentTypes['verifyEmail'][0])
    {

        if ($userServiceVerifyEmailRequest === null || (is_array($userServiceVerifyEmailRequest) && count($userServiceVerifyEmailRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyEmailRequest when calling verifyEmail'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyEmail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyEmailRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyEmailRequest));
            } else {
                $httpBody = $userServiceVerifyEmailRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyInviteCode
     *
     * VerifyInviteCode
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyInviteCodeRequest $userServiceVerifyInviteCodeRequest userServiceVerifyInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyInviteCode'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse
     * @throws ApiException
     */
    public function verifyInviteCode(    $userServiceVerifyInviteCodeRequest,string $contentType = self::contentTypes['verifyInviteCode'][0])
    {
        $request = $this->verifyInviteCodeRequest($userServiceVerifyInviteCodeRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyInviteCodeResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyInviteCode'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyInviteCodeRequest $userServiceVerifyInviteCodeRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyInviteCode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyInviteCodeRequest($userServiceVerifyInviteCodeRequest, string $contentType = self::contentTypes['verifyInviteCode'][0])
    {

        if ($userServiceVerifyInviteCodeRequest === null || (is_array($userServiceVerifyInviteCodeRequest) && count($userServiceVerifyInviteCodeRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyInviteCodeRequest when calling verifyInviteCode'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyInviteCode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyInviteCodeRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyInviteCodeRequest));
            } else {
                $httpBody = $userServiceVerifyInviteCodeRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyPasskeyRegistration
     *
     * VerifyPasskeyRegistration
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationRequest $userServiceVerifyPasskeyRegistrationRequest userServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse
     * @throws ApiException
     */
    public function verifyPasskeyRegistration(    $userServiceVerifyPasskeyRegistrationRequest,string $contentType = self::contentTypes['verifyPasskeyRegistration'][0])
    {
        $request = $this->verifyPasskeyRegistrationRequest($userServiceVerifyPasskeyRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyPasskeyRegistration'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyPasskeyRegistrationRequest $userServiceVerifyPasskeyRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPasskeyRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyPasskeyRegistrationRequest($userServiceVerifyPasskeyRegistrationRequest, string $contentType = self::contentTypes['verifyPasskeyRegistration'][0])
    {

        if ($userServiceVerifyPasskeyRegistrationRequest === null || (is_array($userServiceVerifyPasskeyRegistrationRequest) && count($userServiceVerifyPasskeyRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyPasskeyRegistrationRequest when calling verifyPasskeyRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyPasskeyRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyPasskeyRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyPasskeyRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyPasskeyRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyPhone
     *
     * VerifyPhone
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyPhoneRequest $userServiceVerifyPhoneRequest userServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPhone'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyPhoneResponse
     * @throws ApiException
     */
    public function verifyPhone(    $userServiceVerifyPhoneRequest,string $contentType = self::contentTypes['verifyPhone'][0])
    {
        $request = $this->verifyPhoneRequest($userServiceVerifyPhoneRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyPhoneResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyPhoneResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyPhone'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyPhoneRequest $userServiceVerifyPhoneRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyPhone'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyPhoneRequest($userServiceVerifyPhoneRequest, string $contentType = self::contentTypes['verifyPhone'][0])
    {

        if ($userServiceVerifyPhoneRequest === null || (is_array($userServiceVerifyPhoneRequest) && count($userServiceVerifyPhoneRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyPhoneRequest when calling verifyPhone'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyPhone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyPhoneRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyPhoneRequest));
            } else {
                $httpBody = $userServiceVerifyPhoneRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyTOTPRegistration
     *
     * VerifyTOTPRegistration
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationRequest $userServiceVerifyTOTPRegistrationRequest userServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyTOTPRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse
     * @throws ApiException
     */
    public function verifyTOTPRegistration(    $userServiceVerifyTOTPRegistrationRequest,string $contentType = self::contentTypes['verifyTOTPRegistration'][0])
    {
        $request = $this->verifyTOTPRegistrationRequest($userServiceVerifyTOTPRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyTOTPRegistration'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyTOTPRegistrationRequest $userServiceVerifyTOTPRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyTOTPRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyTOTPRegistrationRequest($userServiceVerifyTOTPRegistrationRequest, string $contentType = self::contentTypes['verifyTOTPRegistration'][0])
    {

        if ($userServiceVerifyTOTPRegistrationRequest === null || (is_array($userServiceVerifyTOTPRegistrationRequest) && count($userServiceVerifyTOTPRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyTOTPRegistrationRequest when calling verifyTOTPRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyTOTPRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyTOTPRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyTOTPRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyTOTPRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyU2FRegistration
     *
     * VerifyU2FRegistration
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationRequest $userServiceVerifyU2FRegistrationRequest userServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyU2FRegistration'] to see the possible values for this operation
     *
     * @return \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse
     * @throws ApiException
     */
    public function verifyU2FRegistration(    $userServiceVerifyU2FRegistrationRequest,string $contentType = self::contentTypes['verifyU2FRegistration'][0])
    {
        $request = $this->verifyU2FRegistrationRequest($userServiceVerifyU2FRegistrationRequest, $contentType);

        $responseTypes = [
            200 => '\Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse',
            'default' => '\Zitadel\Client\Model\UserServiceConnectError',
        ];
        $defaultSignatureType = '\Zitadel\Client\Model\UserServiceVerifyU2FRegistrationResponse';
        return $this->executeRequest($request, $responseTypes, $defaultSignatureType);
    }

    /**
     * Create request for operation 'verifyU2FRegistration'
     *
     * @param  \Zitadel\Client\Model\UserServiceVerifyU2FRegistrationRequest $userServiceVerifyU2FRegistrationRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyU2FRegistration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    private function verifyU2FRegistrationRequest($userServiceVerifyU2FRegistrationRequest, string $contentType = self::contentTypes['verifyU2FRegistration'][0])
    {

        if ($userServiceVerifyU2FRegistrationRequest === null || (is_array($userServiceVerifyU2FRegistrationRequest) && count($userServiceVerifyU2FRegistrationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userServiceVerifyU2FRegistrationRequest when calling verifyU2FRegistration'
            );
        }


        $resourcePath = '/zitadel.user.v2.UserService/VerifyU2FRegistration';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );
        if (isset($userServiceVerifyU2FRegistrationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userServiceVerifyU2FRegistrationRequest));
            } else {
                $httpBody = $userServiceVerifyU2FRegistrationRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                $httpBody = ObjectSerializer::buildQuery($formParams, $this->config->getBooleanFormatForQueryString());
            }
        }

        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams, $this->config->getBooleanFormatForQueryString());
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
